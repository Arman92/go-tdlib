// AUTOGENERATED - DO NOT EDIT

package client

import (
	"encoding/json"

	"github.com/Arman92/go-tdlib/v2/tdlib"
)

// GetMessageEmbeddingCode Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
// @param chatID Identifier of the chat to which the message belongs
// @param messageID Identifier of the message
// @param forAlbum Pass true to return an HTML code for embedding of the whole media album
func (client *Client) GetMessageEmbeddingCode(chatID int64, messageID int64, forAlbum bool) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "getMessageEmbeddingCode",
		"chat_id":    chatID,
		"message_id": messageID,
		"for_album":  forAlbum,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetFileMimeType Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
// @param fileName The name of the file or path to the file
func (client *Client) GetFileMimeType(fileName string) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "getFileMimeType",
		"file_name": fileName,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetFileExtension Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
// @param mimeType The MIME type of the file
func (client *Client) GetFileExtension(mimeType string) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "getFileExtension",
		"mime_type": mimeType,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// CleanFileName Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
// @param fileName File name or path to the file
func (client *Client) CleanFileName(fileName string) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "cleanFileName",
		"file_name": fileName,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetJsonString Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
// @param jsonStringValue The JsonValue object
func (client *Client) GetJsonString(jsonStringValue tdlib.JsonValue) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "getJsonString",
		"json_value": jsonStringValue,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetChatFilterDefaultIconName Returns default icon name for a filter. Can be called synchronously
// @param filter Chat filter
func (client *Client) GetChatFilterDefaultIconName(filter *tdlib.ChatFilter) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":  "getChatFilterDefaultIconName",
		"filter": filter,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetSuggestedFileName Returns suggested name for saving a file in a given directory
// @param fileID Identifier of the file
// @param directory Directory in which the file is supposed to be saved
func (client *Client) GetSuggestedFileName(fileID int32, directory string) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "getSuggestedFileName",
		"file_id":   fileID,
		"directory": directory,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetMessageImportConfirmationText Returns a confirmation text to be shown to the user before starting message import
// @param chatID Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
func (client *Client) GetMessageImportConfirmationText(chatID int64) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "getMessageImportConfirmationText",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// JoinGroupCall Joins an active group call. Returns join response payload for tgcalls
// @param groupCallID Group call identifier
// @param participantID Identifier of a group call participant, which will be used to join the call; voice chats only
// @param audioSourceID Caller audio channel synchronization source identifier; received from tgcalls
// @param payload Group call join payload; received from tgcalls
// @param isMuted True, if the user's microphone is muted
// @param isMyVideoEnabled True, if the user's video is enabled
// @param inviteHash If non-empty, invite hash to be used to join the group call without being muted by administrators
func (client *Client) JoinGroupCall(groupCallID int32, participantID tdlib.MessageSender, audioSourceID int32, payload string, isMuted bool, isMyVideoEnabled bool, inviteHash string) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":               "joinGroupCall",
		"group_call_id":       groupCallID,
		"participant_id":      participantID,
		"audio_source_id":     audioSourceID,
		"payload":             payload,
		"is_muted":            isMuted,
		"is_my_video_enabled": isMyVideoEnabled,
		"invite_hash":         inviteHash,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// StartGroupCallScreenSharing Starts screen sharing in a joined group call. Returns join response payload for tgcalls
// @param groupCallID Group call identifier
// @param audioSourceID Screen sharing audio channel synchronization source identifier; received from tgcalls
// @param payload Group call join payload; received from tgcalls
func (client *Client) StartGroupCallScreenSharing(groupCallID int32, audioSourceID int32, payload string) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "startGroupCallScreenSharing",
		"group_call_id":   groupCallID,
		"audio_source_id": audioSourceID,
		"payload":         payload,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetPreferredCountryLanguage Returns an IETF language tag of the language preferred in the country, which should be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
// @param countryCode A two-letter ISO 3166-1 alpha-2 country code
func (client *Client) GetPreferredCountryLanguage(countryCode string) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":        "getPreferredCountryLanguage",
		"country_code": countryCode,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetSuggestedStickerSetName Returns a suggested name for a new sticker set with a given title
// @param title Sticker set title; 1-64 characters
func (client *Client) GetSuggestedStickerSetName(title string) (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "getSuggestedStickerSetName",
		"title": title,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}

// GetCountryCode Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
func (client *Client) GetCountryCode() (*tdlib.Text, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "getCountryCode",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var text tdlib.Text
	err = json.Unmarshal(result.Raw, &text)
	return &text, err

}
