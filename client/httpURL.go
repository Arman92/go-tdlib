// AUTOGENERATED - DO NOT EDIT

package client

import (
	"encoding/json"

	"github.com/Arman92/go-tdlib/v2/tdlib"
)

// GetLoginURL Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl. Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
// @param chatID Chat identifier of the message with the button
// @param messageID Message identifier of the message with the button
// @param buttonID Button identifier
// @param allowWriteAccess True, if the user allowed the bot to send them messages
func (client *Client) GetLoginURL(chatID int64, messageID int64, buttonID int64, allowWriteAccess bool) (*tdlib.HttpURL, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":              "getLoginUrl",
		"chat_id":            chatID,
		"message_id":         messageID,
		"button_id":          buttonID,
		"allow_write_access": allowWriteAccess,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var httpURL tdlib.HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}

// GetExternalLink Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
// @param link The HTTP link
// @param allowWriteAccess True, if the current user allowed the bot, returned in getExternalLinkInfo, to send them messages
func (client *Client) GetExternalLink(link string, allowWriteAccess bool) (*tdlib.HttpURL, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":              "getExternalLink",
		"link":               link,
		"allow_write_access": allowWriteAccess,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var httpURL tdlib.HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}

// GetGroupCallInviteLink Returns invite link to a voice chat in a public chat
// @param groupCallID Group call identifier
// @param canSelfUnmute Pass true if the invite_link should contain an invite hash, passing which to joinGroupCall would allow the invited user to unmute themselves. Requires groupCall.can_be_managed group call flag
func (client *Client) GetGroupCallInviteLink(groupCallID int32, canSelfUnmute bool) (*tdlib.HttpURL, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "getGroupCallInviteLink",
		"group_call_id":   groupCallID,
		"can_self_unmute": canSelfUnmute,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var httpURL tdlib.HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}

// GetEmojiSuggestionsURL Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
// @param languageCode Language code for which the emoji replacements will be suggested
func (client *Client) GetEmojiSuggestionsURL(languageCode string) (*tdlib.HttpURL, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "getEmojiSuggestionsUrl",
		"language_code": languageCode,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var httpURL tdlib.HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}

// GetBackgroundURL Constructs a persistent HTTP URL for a background
// @param name Background name
// @param typeParam Background type
func (client *Client) GetBackgroundURL(name string, typeParam tdlib.BackgroundType) (*tdlib.HttpURL, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "getBackgroundUrl",
		"name":  name,
		"type":  typeParam,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var httpURL tdlib.HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}

// GetChatStatisticsURL Returns an HTTP URL with the chat statistics. Currently this method of getting the statistics are disabled and can be deleted in the future
// @param chatID Chat identifier
// @param parameters Parameters for the request
// @param isDark Pass true if a URL with the dark theme must be returned
func (client *Client) GetChatStatisticsURL(chatID int64, parameters string, isDark bool) (*tdlib.HttpURL, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "getChatStatisticsUrl",
		"chat_id":    chatID,
		"parameters": parameters,
		"is_dark":    isDark,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var httpURL tdlib.HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}

// GetApplicationDownloadLink Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
func (client *Client) GetApplicationDownloadLink() (*tdlib.HttpURL, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "getApplicationDownloadLink",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var httpURL tdlib.HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}

// GetProxyLink Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
// @param proxyID Proxy identifier
func (client *Client) GetProxyLink(proxyID int32) (*tdlib.HttpURL, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "getProxyLink",
		"proxy_id": proxyID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var httpURL tdlib.HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}
