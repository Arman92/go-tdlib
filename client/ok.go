// AUTOGENERATED - DO NOT EDIT

package client

import (
	"encoding/json"

	"github.com/Arman92/go-tdlib/v2/tdlib"
)

// SetTdlibParameters Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
// @param parameters Parameters
func (client *Client) SetTdlibParameters(parameters *tdlib.TdlibParameters) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "setTdlibParameters",
		"parameters": parameters,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckDatabaseEncryptionKey Checks the database encryption key for correctness. Works only when the current authorization state is authorizationStateWaitEncryptionKey
// @param encryptionKey Encryption key to check or set up
func (client *Client) CheckDatabaseEncryptionKey(encryptionKey []byte) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "checkDatabaseEncryptionKey",
		"encryption_key": encryptionKey,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetAuthenticationPhoneNumber Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber, or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
// @param phoneNumber The phone number of the user, in international format
// @param settings Settings for the authentication of the user's phone number
func (client *Client) SetAuthenticationPhoneNumber(phoneNumber string, settings *tdlib.PhoneNumberAuthenticationSettings) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":        "setAuthenticationPhoneNumber",
		"phone_number": phoneNumber,
		"settings":     settings,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ResendAuthenticationCode Re-sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed
func (client *Client) ResendAuthenticationCode() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "resendAuthenticationCode",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckAuthenticationCode Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
// @param code The verification code received via SMS, Telegram message, phone call, or flash call
func (client *Client) CheckAuthenticationCode(code string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "checkAuthenticationCode",
		"code":  code,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RequestQrCodeAuthentication Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber, or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
// @param otherUserIDs List of user identifiers of other users currently using the application
func (client *Client) RequestQrCodeAuthentication(otherUserIDs []int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "requestQrCodeAuthentication",
		"other_user_ids": otherUserIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RegisterUser Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
// @param firstName The first name of the user; 1-64 characters
// @param lastName The last name of the user; 0-64 characters
func (client *Client) RegisterUser(firstName string, lastName string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "registerUser",
		"first_name": firstName,
		"last_name":  lastName,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckAuthenticationPassword Checks the authentication password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
// @param password The password to check
func (client *Client) CheckAuthenticationPassword(password string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "checkAuthenticationPassword",
		"password": password,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RequestAuthenticationPasswordRecovery Requests to send a password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
func (client *Client) RequestAuthenticationPasswordRecovery() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "requestAuthenticationPasswordRecovery",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckAuthenticationPasswordRecoveryCode Checks whether a password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
// @param recoveryCode Recovery code to check
func (client *Client) CheckAuthenticationPasswordRecoveryCode(recoveryCode string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "checkAuthenticationPasswordRecoveryCode",
		"recovery_code": recoveryCode,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RecoverAuthenticationPassword Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
// @param recoveryCode Recovery code to check
// @param newPassword New password of the user; may be empty to remove the password
// @param newHint New password hint; may be empty
func (client *Client) RecoverAuthenticationPassword(recoveryCode string, newPassword string, newHint string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "recoverAuthenticationPassword",
		"recovery_code": recoveryCode,
		"new_password":  newPassword,
		"new_hint":      newHint,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckAuthenticationBotToken Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
// @param token The bot token
func (client *Client) CheckAuthenticationBotToken(token string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "checkAuthenticationBotToken",
		"token": token,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var okDummy tdlib.Ok
	err = json.Unmarshal(result.Raw, &okDummy)
	return &okDummy, err

}

// LogOut Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
func (client *Client) LogOut() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "logOut",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// Close Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
func (client *Client) Close() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "close",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// Destroy Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
func (client *Client) Destroy() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "destroy",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetDatabaseEncryptionKey Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
// @param newEncryptionKey New encryption key
func (client *Client) SetDatabaseEncryptionKey(newEncryptionKey []byte) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":              "setDatabaseEncryptionKey",
		"new_encryption_key": newEncryptionKey,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckPasswordRecoveryCode Checks whether a 2-step verification password recovery code sent to an email address is valid
// @param recoveryCode Recovery code to check
func (client *Client) CheckPasswordRecoveryCode(recoveryCode string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "checkPasswordRecoveryCode",
		"recovery_code": recoveryCode,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CancelPasswordReset Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0
func (client *Client) CancelPasswordReset() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "cancelPasswordReset",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// LoadChats Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats has been loaded
// @param chatList The chat list in which to load chats
// @param limit The maximum number of chats to be loaded. For optimal performance, the number of loaded chats is chosen by TDLib and can be smaller than the specified limit, even if the end of the list is not reached
func (client *Client) LoadChats(chatList tdlib.ChatList, limit int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "loadChats",
		"chat_list": chatList,
		"limit":     limit,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveTopChat Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
// @param category Category of frequently used chats
// @param chatID Chat identifier
func (client *Client) RemoveTopChat(category tdlib.TopChatCategory, chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "removeTopChat",
		"category": category,
		"chat_id":  chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddRecentlyFoundChat Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
// @param chatID Identifier of the chat to add
func (client *Client) AddRecentlyFoundChat(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "addRecentlyFoundChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveRecentlyFoundChat Removes a chat from the list of recently found chats
// @param chatID Identifier of the chat to be removed
func (client *Client) RemoveRecentlyFoundChat(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "removeRecentlyFoundChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ClearRecentlyFoundChats Clears the list of recently found chats
func (client *Client) ClearRecentlyFoundChats() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "clearRecentlyFoundChats",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckCreatedPublicChatsLimit Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached
// @param typeParam Type of the public chats, for which to check the limit
func (client *Client) CheckCreatedPublicChatsLimit(typeParam tdlib.PublicChatType) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "checkCreatedPublicChatsLimit",
		"type":  typeParam,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteChatHistory Deletes all messages in the chat. Use Chat.can_be_deleted_only_for_self and Chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
// @param chatID Chat identifier
// @param removeFromChatList Pass true if the chat should be removed from the chat list
// @param revoke Pass true to try to delete chat history for all users
func (client *Client) DeleteChatHistory(chatID int64, removeFromChatList bool, revoke bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "deleteChatHistory",
		"chat_id":               chatID,
		"remove_from_chat_list": removeFromChatList,
		"revoke":                revoke,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var okDummy tdlib.Ok
	err = json.Unmarshal(result.Raw, &okDummy)
	return &okDummy, err

}

// DeleteChat Deletes a chat along with all messages in the corresponding chat for all chat members; requires owner privileges. For group chats this will release the username and remove all members. Chats with more than 1000 members can't be deleted using this method
// @param chatID Chat identifier
func (client *Client) DeleteChat(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "deleteChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteAllCallMessages Deletes all call messages
// @param revoke Pass true to delete the messages for all users
func (client *Client) DeleteAllCallMessages(revoke bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":  "deleteAllCallMessages",
		"revoke": revoke,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var okDummy tdlib.Ok
	err = json.Unmarshal(result.Raw, &okDummy)
	return &okDummy, err

}

// ViewSponsoredMessage Informs TDLib that a sponsored message was viewed by the user
// @param chatID Identifier of the chat with the sponsored message
// @param sponsoredMessageID The identifier of the sponsored message being viewed
func (client *Client) ViewSponsoredMessage(chatID int64, sponsoredMessageID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                "viewSponsoredMessage",
		"chat_id":              chatID,
		"sponsored_message_id": sponsoredMessageID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveNotification Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
// @param notificationGroupID Identifier of notification group to which the notification belongs
// @param notificationID Identifier of removed notification
func (client *Client) RemoveNotification(notificationGroupID int32, notificationID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "removeNotification",
		"notification_group_id": notificationGroupID,
		"notification_id":       notificationID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveNotificationGroup Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
// @param notificationGroupID Notification group identifier
// @param maxNotificationID The maximum identifier of removed notifications
func (client *Client) RemoveNotificationGroup(notificationGroupID int32, maxNotificationID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "removeNotificationGroup",
		"notification_group_id": notificationGroupID,
		"max_notification_id":   maxNotificationID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SendChatScreenshotTakenNotification Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats
// @param chatID Chat identifier
func (client *Client) SendChatScreenshotTakenNotification(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "sendChatScreenshotTakenNotification",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteMessages Deletes messages
// @param chatID Chat identifier
// @param messageIDs Identifiers of the messages to be deleted
// @param revoke Pass true to try to delete messages for all chat members. Always true for supergroups, channels and secret chats
func (client *Client) DeleteMessages(chatID int64, messageIDs []int64, revoke bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":       "deleteMessages",
		"chat_id":     chatID,
		"message_ids": messageIDs,
		"revoke":      revoke,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var okDummy tdlib.Ok
	err = json.Unmarshal(result.Raw, &okDummy)
	return &okDummy, err

}

// DeleteChatMessagesFromUser Deletes all messages sent by the specified user to a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
// @param chatID Chat identifier
// @param userID User identifier
func (client *Client) DeleteChatMessagesFromUser(chatID int64, userID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "deleteChatMessagesFromUser",
		"chat_id": chatID,
		"user_id": userID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EditInlineMessageText Edits the text of an inline text or game message sent via a bot; for bots only
// @param inlineMessageID Inline message identifier
// @param replyMarkup The new message reply markup
// @param inputMessageContent New text content of the message. Should be of type inputMessageText
func (client *Client) EditInlineMessageText(inlineMessageID string, replyMarkup tdlib.ReplyMarkup, inputMessageContent tdlib.InputMessageContent) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "editInlineMessageText",
		"inline_message_id":     inlineMessageID,
		"reply_markup":          replyMarkup,
		"input_message_content": inputMessageContent,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EditInlineMessageLiveLocation Edits the content of a live location in an inline message sent via a bot; for bots only
// @param inlineMessageID Inline message identifier
// @param replyMarkup The new message reply markup
// @param location New location content of the message; may be null. Pass null to stop sharing the live location
// @param heading The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
// @param proximityAlertRadius The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
func (client *Client) EditInlineMessageLiveLocation(inlineMessageID string, replyMarkup tdlib.ReplyMarkup, location *tdlib.Location, heading int32, proximityAlertRadius int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                  "editInlineMessageLiveLocation",
		"inline_message_id":      inlineMessageID,
		"reply_markup":           replyMarkup,
		"location":               location,
		"heading":                heading,
		"proximity_alert_radius": proximityAlertRadius,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EditInlineMessageMedia Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
// @param inlineMessageID Inline message identifier
// @param replyMarkup The new message reply markup; for bots only
// @param inputMessageContent New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
func (client *Client) EditInlineMessageMedia(inlineMessageID string, replyMarkup tdlib.ReplyMarkup, inputMessageContent tdlib.InputMessageContent) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "editInlineMessageMedia",
		"inline_message_id":     inlineMessageID,
		"reply_markup":          replyMarkup,
		"input_message_content": inputMessageContent,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EditInlineMessageCaption Edits the caption of an inline message sent via a bot; for bots only
// @param inlineMessageID Inline message identifier
// @param replyMarkup The new message reply markup
// @param caption New message content caption; 0-GetOption("message_caption_length_max") characters
func (client *Client) EditInlineMessageCaption(inlineMessageID string, replyMarkup tdlib.ReplyMarkup, caption *tdlib.FormattedText) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "editInlineMessageCaption",
		"inline_message_id": inlineMessageID,
		"reply_markup":      replyMarkup,
		"caption":           caption,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EditInlineMessageReplyMarkup Edits the reply markup of an inline message sent via a bot; for bots only
// @param inlineMessageID Inline message identifier
// @param replyMarkup The new message reply markup
func (client *Client) EditInlineMessageReplyMarkup(inlineMessageID string, replyMarkup tdlib.ReplyMarkup) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "editInlineMessageReplyMarkup",
		"inline_message_id": inlineMessageID,
		"reply_markup":      replyMarkup,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EditMessageSchedulingState Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
// @param chatID The chat the message belongs to
// @param messageID Identifier of the message
// @param schedulingState The new message scheduling state. Pass null to send the message immediately
func (client *Client) EditMessageSchedulingState(chatID int64, messageID int64, schedulingState tdlib.MessageSchedulingState) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":            "editMessageSchedulingState",
		"chat_id":          chatID,
		"message_id":       messageID,
		"scheduling_state": schedulingState,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetPollAnswer Changes the user answer to a poll. A poll in quiz mode can be answered only once
// @param chatID Identifier of the chat to which the poll belongs
// @param messageID Identifier of the message containing the poll
// @param optionIDs 0-based identifiers of answer options, chosen by the user. User can choose more than 1 answer option only is the poll allows multiple answers
func (client *Client) SetPollAnswer(chatID int64, messageID int64, optionIDs []int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "setPollAnswer",
		"chat_id":    chatID,
		"message_id": messageID,
		"option_ids": optionIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// StopPoll Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set
// @param chatID Identifier of the chat to which the poll belongs
// @param messageID Identifier of the message containing the poll
// @param replyMarkup The new message reply markup; for bots only
func (client *Client) StopPoll(chatID int64, messageID int64, replyMarkup tdlib.ReplyMarkup) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":        "stopPoll",
		"chat_id":      chatID,
		"message_id":   messageID,
		"reply_markup": replyMarkup,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// HideSuggestedAction Hides a suggested action
// @param action Suggested action to hide
func (client *Client) HideSuggestedAction(action tdlib.SuggestedAction) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":  "hideSuggestedAction",
		"action": action,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AnswerInlineQuery Sets the result of an inline query; for bots only
// @param inlineQueryID Identifier of the inline query
// @param isPersonal True, if the result of the query can be cached for the specified user
// @param results The results of the query
// @param cacheTime Allowed time to cache the results of the query, in seconds
// @param nextOffset Offset for the next inline query; pass an empty string if there are no more results
// @param switchPmText If non-empty, this text should be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter
// @param switchPmParameter The parameter for the bot start message
func (client *Client) AnswerInlineQuery(inlineQueryID *tdlib.JSONInt64, isPersonal bool, results []tdlib.InputInlineQueryResult, cacheTime int32, nextOffset string, switchPmText string, switchPmParameter string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":               "answerInlineQuery",
		"inline_query_id":     inlineQueryID,
		"is_personal":         isPersonal,
		"results":             results,
		"cache_time":          cacheTime,
		"next_offset":         nextOffset,
		"switch_pm_text":      switchPmText,
		"switch_pm_parameter": switchPmParameter,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AnswerCallbackQuery Sets the result of a callback query; for bots only
// @param callbackQueryID Identifier of the callback query
// @param text Text of the answer
// @param showAlert If true, an alert should be shown to the user instead of a toast notification
// @param uRL URL to be opened
// @param cacheTime Time during which the result of the query can be cached, in seconds
func (client *Client) AnswerCallbackQuery(callbackQueryID *tdlib.JSONInt64, text string, showAlert bool, uRL string, cacheTime int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "answerCallbackQuery",
		"callback_query_id": callbackQueryID,
		"text":              text,
		"show_alert":        showAlert,
		"url":               uRL,
		"cache_time":        cacheTime,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AnswerShippingQuery Sets the result of a shipping query; for bots only
// @param shippingQueryID Identifier of the shipping query
// @param shippingOptions Available shipping options
// @param errorMessage An error message, empty on success
func (client *Client) AnswerShippingQuery(shippingQueryID *tdlib.JSONInt64, shippingOptions []tdlib.ShippingOption, errorMessage string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "answerShippingQuery",
		"shipping_query_id": shippingQueryID,
		"shipping_options":  shippingOptions,
		"error_message":     errorMessage,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AnswerPreCheckoutQuery Sets the result of a pre-checkout query; for bots only
// @param preCheckoutQueryID Identifier of the pre-checkout query
// @param errorMessage An error message, empty on success
func (client *Client) AnswerPreCheckoutQuery(preCheckoutQueryID *tdlib.JSONInt64, errorMessage string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "answerPreCheckoutQuery",
		"pre_checkout_query_id": preCheckoutQueryID,
		"error_message":         errorMessage,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetInlineGameScore Updates the game score of the specified user in a game; for bots only
// @param inlineMessageID Inline message identifier
// @param editMessage True, if the message should be edited
// @param userID User identifier
// @param score The new score
// @param force Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
func (client *Client) SetInlineGameScore(inlineMessageID string, editMessage bool, userID int64, score int32, force bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "setInlineGameScore",
		"inline_message_id": inlineMessageID,
		"edit_message":      editMessage,
		"user_id":           userID,
		"score":             score,
		"force":             force,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteChatReplyMarkup Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup will be changed
// @param chatID Chat identifier
// @param messageID The message identifier of the used keyboard
func (client *Client) DeleteChatReplyMarkup(chatID int64, messageID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "deleteChatReplyMarkup",
		"chat_id":    chatID,
		"message_id": messageID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SendChatAction Sends a notification about user activity in a chat
// @param chatID Chat identifier
// @param messageThreadID If not 0, a message thread identifier in which the action was performed
// @param action The action description
func (client *Client) SendChatAction(chatID int64, messageThreadID int64, action tdlib.ChatAction) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "sendChatAction",
		"chat_id":           chatID,
		"message_thread_id": messageThreadID,
		"action":            action,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// OpenChat Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
// @param chatID Chat identifier
func (client *Client) OpenChat(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "openChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CloseChat Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
// @param chatID Chat identifier
func (client *Client) CloseChat(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "closeChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ViewMessages Informs TDLib that messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
// @param chatID Chat identifier
// @param messageThreadID If not 0, a message thread identifier in which the messages are being viewed
// @param messageIDs The identifiers of the messages being viewed
// @param forceRead True, if messages in closed chats should be marked as read by the request
func (client *Client) ViewMessages(chatID int64, messageThreadID int64, messageIDs []int64, forceRead bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "viewMessages",
		"chat_id":           chatID,
		"message_thread_id": messageThreadID,
		"message_ids":       messageIDs,
		"force_read":        forceRead,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// OpenMessageContent Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An updateMessageContentOpened update will be generated if something has changed
// @param chatID Chat identifier of the message
// @param messageID Identifier of the message with the opened content
func (client *Client) OpenMessageContent(chatID int64, messageID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "openMessageContent",
		"chat_id":    chatID,
		"message_id": messageID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ReadAllChatMentions Marks all mentions in a chat as read
// @param chatID Chat identifier
func (client *Client) ReadAllChatMentions(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "readAllChatMentions",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddChatToList Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
// @param chatID Chat identifier
// @param chatList The chat list. Use getChatListsToAddChat to get suitable chat lists
func (client *Client) AddChatToList(chatID int64, chatList tdlib.ChatList) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "addChatToList",
		"chat_id":   chatID,
		"chat_list": chatList,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteChatFilter Deletes existing chat filter
// @param chatFilterID Chat filter identifier
func (client *Client) DeleteChatFilter(chatFilterID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "deleteChatFilter",
		"chat_filter_id": chatFilterID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ReorderChatFilters Changes the order of chat filters
// @param chatFilterIDs Identifiers of chat filters in the new correct order
func (client *Client) ReorderChatFilters(chatFilterIDs []int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "reorderChatFilters",
		"chat_filter_ids": chatFilterIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatTitle Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
// @param chatID Chat identifier
// @param title New title of the chat; 1-128 characters
func (client *Client) SetChatTitle(chatID int64, title string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "setChatTitle",
		"chat_id": chatID,
		"title":   title,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatPhoto Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
// @param chatID Chat identifier
// @param photo New chat photo. Pass null to delete the chat photo
func (client *Client) SetChatPhoto(chatID int64, photo tdlib.InputChatPhoto) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "setChatPhoto",
		"chat_id": chatID,
		"photo":   photo,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatMessageTTLSetting Changes the message TTL setting (sets a new self-destruct timer) in a chat. Requires can_delete_messages administrator right in basic groups, supergroups and channels Message TTL setting of a chat with the current user (Saved Messages) and the chat 777000 (Telegram) can't be changed
// @param chatID Chat identifier
// @param tTL New TTL value, in seconds; must be one of 0, 86400, 7 * 86400, or 31 * 86400 unless the chat is secret
func (client *Client) SetChatMessageTTLSetting(chatID int64, tTL int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "setChatMessageTtlSetting",
		"chat_id": chatID,
		"ttl":     tTL,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatPermissions Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
// @param chatID Chat identifier
// @param permissions New non-administrator members permissions in the chat
func (client *Client) SetChatPermissions(chatID int64, permissions *tdlib.ChatPermissions) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":       "setChatPermissions",
		"chat_id":     chatID,
		"permissions": permissions,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatTheme Changes the chat theme. Supported only in private and secret chats
// @param chatID Chat identifier
// @param themeName Name of the new chat theme; may be empty to return the default theme
func (client *Client) SetChatTheme(chatID int64, themeName string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "setChatTheme",
		"chat_id":    chatID,
		"theme_name": themeName,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatDraftMessage Changes the draft message in a chat
// @param chatID Chat identifier
// @param messageThreadID If not 0, a message thread identifier in which the draft was changed
// @param draftMessage New draft message; may be null
func (client *Client) SetChatDraftMessage(chatID int64, messageThreadID int64, draftMessage *tdlib.DraftMessage) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "setChatDraftMessage",
		"chat_id":           chatID,
		"message_thread_id": messageThreadID,
		"draft_message":     draftMessage,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatNotificationSettings Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
// @param chatID Chat identifier
// @param notificationSettings New notification settings for the chat. If the chat is muted for more than 1 week, it is considered to be muted forever
func (client *Client) SetChatNotificationSettings(chatID int64, notificationSettings *tdlib.ChatNotificationSettings) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "setChatNotificationSettings",
		"chat_id":               chatID,
		"notification_settings": notificationSettings,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleChatIsMarkedAsUnread Changes the marked as unread state of a chat
// @param chatID Chat identifier
// @param isMarkedAsUnread New value of is_marked_as_unread
func (client *Client) ToggleChatIsMarkedAsUnread(chatID int64, isMarkedAsUnread bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":               "toggleChatIsMarkedAsUnread",
		"chat_id":             chatID,
		"is_marked_as_unread": isMarkedAsUnread,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleChatDefaultDisableNotification Changes the value of the default disable_notification parameter, used when a message is sent to a chat
// @param chatID Chat identifier
// @param defaultDisableNotification New value of default_disable_notification
func (client *Client) ToggleChatDefaultDisableNotification(chatID int64, defaultDisableNotification bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                        "toggleChatDefaultDisableNotification",
		"chat_id":                      chatID,
		"default_disable_notification": defaultDisableNotification,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatClientData Changes application-specific data associated with a chat
// @param chatID Chat identifier
// @param clientData New value of client_data
func (client *Client) SetChatClientData(chatID int64, clientData string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":       "setChatClientData",
		"chat_id":     chatID,
		"client_data": clientData,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatDescription Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
// @param chatID Identifier of the chat
// @param description New chat description; 0-255 characters
func (client *Client) SetChatDescription(chatID int64, description string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":       "setChatDescription",
		"chat_id":     chatID,
		"description": description,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatDiscussionGroup Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
// @param chatID Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed in the second argument to a linked channel chat (requires can_pin_messages rights in the supergroup)
// @param discussionChatID Identifier of a new channel's discussion group. Use 0 to remove the discussion group. Use the method getSuitableDiscussionChats to find all suitable groups. Basic group chats must be first upgraded to supergroup chats. If new chat members don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable must be used first to change that
func (client *Client) SetChatDiscussionGroup(chatID int64, discussionChatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":              "setChatDiscussionGroup",
		"chat_id":            chatID,
		"discussion_chat_id": discussionChatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatLocation Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
// @param chatID Chat identifier
// @param location New location for the chat; must be valid and not null
func (client *Client) SetChatLocation(chatID int64, location *tdlib.ChatLocation) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "setChatLocation",
		"chat_id":  chatID,
		"location": location,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatSlowModeDelay Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
// @param chatID Chat identifier
// @param slowModeDelay New slow mode delay for the chat; must be one of 0, 10, 30, 60, 300, 900, 3600
func (client *Client) SetChatSlowModeDelay(chatID int64, slowModeDelay int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "setChatSlowModeDelay",
		"chat_id":         chatID,
		"slow_mode_delay": slowModeDelay,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// PinChatMessage Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
// @param chatID Identifier of the chat
// @param messageID Identifier of the new pinned message
// @param disableNotification True, if there should be no notification about the pinned message. Notifications are always disabled in channels and private chats
// @param onlyForSelf True, if the message needs to be pinned for one side only; private chats only
func (client *Client) PinChatMessage(chatID int64, messageID int64, disableNotification bool, onlyForSelf bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                "pinChatMessage",
		"chat_id":              chatID,
		"message_id":           messageID,
		"disable_notification": disableNotification,
		"only_for_self":        onlyForSelf,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// UnpinChatMessage Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
// @param chatID Identifier of the chat
// @param messageID Identifier of the removed pinned message
func (client *Client) UnpinChatMessage(chatID int64, messageID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "unpinChatMessage",
		"chat_id":    chatID,
		"message_id": messageID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// UnpinAllChatMessages Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
// @param chatID Identifier of the chat
func (client *Client) UnpinAllChatMessages(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "unpinAllChatMessages",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// JoinChat Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method
// @param chatID Chat identifier
func (client *Client) JoinChat(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "joinChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// LeaveChat Removes the current user from chat members. Private and secret chats can't be left using this method
// @param chatID Chat identifier
func (client *Client) LeaveChat(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "leaveChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddChatMember Adds a new member to a chat. Members can't be added to private or secret chats
// @param chatID Chat identifier
// @param userID Identifier of the user
// @param forwardLimit The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels
func (client *Client) AddChatMember(chatID int64, userID int64, forwardLimit int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "addChatMember",
		"chat_id":       chatID,
		"user_id":       userID,
		"forward_limit": forwardLimit,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddChatMembers Adds multiple new members to a chat. Currently this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
// @param chatID Chat identifier
// @param userIDs Identifiers of the users to be added to the chat. The maximum number of added users is 20 for supergroups and 100 for channels
func (client *Client) AddChatMembers(chatID int64, userIDs []int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "addChatMembers",
		"chat_id":  chatID,
		"user_ids": userIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetChatMemberStatus Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for adding new members to the chat and transferring chat ownership; instead, use addChatMember or transferChatOwnership
// @param chatID Chat identifier
// @param memberID Member identifier. Chats can be only banned and unbanned in supergroups and channels
// @param status The new status of the member in the chat
func (client *Client) SetChatMemberStatus(chatID int64, memberID tdlib.MessageSender, status tdlib.ChatMemberStatus) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "setChatMemberStatus",
		"chat_id":   chatID,
		"member_id": memberID,
		"status":    status,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// BanChatMember Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
// @param chatID Chat identifier
// @param memberID Member identifier
// @param bannedUntilDate Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Ignored in basic groups
// @param revokeMessages Pass true to delete all messages in the chat for the user that is being removed. Always true for supergroups and channels
func (client *Client) BanChatMember(chatID int64, memberID tdlib.MessageSender, bannedUntilDate int32, revokeMessages bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "banChatMember",
		"chat_id":           chatID,
		"member_id":         memberID,
		"banned_until_date": bannedUntilDate,
		"revoke_messages":   revokeMessages,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var okDummy tdlib.Ok
	err = json.Unmarshal(result.Raw, &okDummy)
	return &okDummy, err

}

// TransferChatOwnership Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
// @param chatID Chat identifier
// @param userID Identifier of the user to which transfer the ownership. The ownership can't be transferred to a bot or to a deleted user
// @param password The password of the current user
func (client *Client) TransferChatOwnership(chatID int64, userID int64, password string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "transferChatOwnership",
		"chat_id":  chatID,
		"user_id":  userID,
		"password": password,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ClearAllDraftMessages Clears draft messages in all chats
// @param excludeSecretChats If true, local draft messages in secret chats will not be cleared
func (client *Client) ClearAllDraftMessages(excludeSecretChats bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                "clearAllDraftMessages",
		"exclude_secret_chats": excludeSecretChats,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetScopeNotificationSettings Changes notification settings for chats of a given type
// @param scope Types of chats for which to change the notification settings
// @param notificationSettings The new notification settings for the given scope
func (client *Client) SetScopeNotificationSettings(scope tdlib.NotificationSettingsScope, notificationSettings *tdlib.ScopeNotificationSettings) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "setScopeNotificationSettings",
		"scope":                 scope,
		"notification_settings": notificationSettings,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ResetAllNotificationSettings Resets all notification settings to their default values. By default, all chats are unmuted, the sound is set to "default" and message previews are shown
func (client *Client) ResetAllNotificationSettings() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "resetAllNotificationSettings",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleChatIsPinned Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/arhive chat list
// @param chatList Chat list in which to change the pinned state of the chat
// @param chatID Chat identifier
// @param isPinned True, if the chat is pinned
func (client *Client) ToggleChatIsPinned(chatList tdlib.ChatList, chatID int64, isPinned bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "toggleChatIsPinned",
		"chat_list": chatList,
		"chat_id":   chatID,
		"is_pinned": isPinned,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetPinnedChats Changes the order of pinned chats
// @param chatList Chat list in which to change the order of pinned chats
// @param chatIDs The new list of pinned chats
func (client *Client) SetPinnedChats(chatList tdlib.ChatList, chatIDs []int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "setPinnedChats",
		"chat_list": chatList,
		"chat_ids":  chatIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CancelDownloadFile Stops the downloading of a file. If a file has already been downloaded, does nothing
// @param fileID Identifier of a file to stop downloading
// @param onlyIfPending Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server
func (client *Client) CancelDownloadFile(fileID int32, onlyIfPending bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "cancelDownloadFile",
		"file_id":         fileID,
		"only_if_pending": onlyIfPending,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CancelUploadFile Stops the uploading of a file. Supported only for files uploaded by using uploadFile. For other files the behavior is undefined
// @param fileID Identifier of the file to stop uploading
func (client *Client) CancelUploadFile(fileID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "cancelUploadFile",
		"file_id": fileID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// WriteGeneratedFilePart Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
// @param generationID The identifier of the generation process
// @param offset The offset from which to write the data to the file
// @param data The data to write
func (client *Client) WriteGeneratedFilePart(generationID *tdlib.JSONInt64, offset int32, data []byte) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "writeGeneratedFilePart",
		"generation_id": generationID,
		"offset":        offset,
		"data":          data,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetFileGenerationProgress Informs TDLib on a file generation progress
// @param generationID The identifier of the generation process
// @param expectedSize Expected size of the generated file, in bytes; 0 if unknown
// @param localPrefixSize The number of bytes already generated
func (client *Client) SetFileGenerationProgress(generationID *tdlib.JSONInt64, expectedSize int32, localPrefixSize int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "setFileGenerationProgress",
		"generation_id":     generationID,
		"expected_size":     expectedSize,
		"local_prefix_size": localPrefixSize,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// FinishFileGeneration Finishes the file generation
// @param generationID The identifier of the generation process
// @param error If set, means that file generation has failed and should be terminated
func (client *Client) FinishFileGeneration(generationID *tdlib.JSONInt64, error *tdlib.Error) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "finishFileGeneration",
		"generation_id": generationID,
		"error":         error,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteFile Deletes a file from the TDLib file cache
// @param fileID Identifier of the file to delete
func (client *Client) DeleteFile(fileID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "deleteFile",
		"file_id": fileID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ImportMessages Imports messages exported from another app
// @param chatID Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
// @param messageFile File with messages to import. Only inputFileLocal and inputFileGenerated are supported. The file must not be previously uploaded
// @param attachedFiles Files used in the imported messages. Only inputFileLocal and inputFileGenerated are supported. The files must not be previously uploaded
func (client *Client) ImportMessages(chatID int64, messageFile tdlib.InputFile, attachedFiles []tdlib.InputFile) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "importMessages",
		"chat_id":        chatID,
		"message_file":   messageFile,
		"attached_files": attachedFiles,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteRevokedChatInviteLink Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
// @param chatID Chat identifier
// @param inviteLink Invite link to revoke
func (client *Client) DeleteRevokedChatInviteLink(chatID int64, inviteLink string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":       "deleteRevokedChatInviteLink",
		"chat_id":     chatID,
		"invite_link": inviteLink,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteAllRevokedChatInviteLinks Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
// @param chatID Chat identifier
// @param creatorUserID User identifier of a chat administrator, which links will be deleted. Must be an identifier of the current user for non-owner
func (client *Client) DeleteAllRevokedChatInviteLinks(chatID int64, creatorUserID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "deleteAllRevokedChatInviteLinks",
		"chat_id":         chatID,
		"creator_user_id": creatorUserID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AcceptCall Accepts an incoming call
// @param callID Call identifier
// @param protocol Description of the call protocols supported by the application
func (client *Client) AcceptCall(callID int32, protocol *tdlib.CallProtocol) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "acceptCall",
		"call_id":  callID,
		"protocol": protocol,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SendCallSignalingData Sends call signaling data
// @param callID Call identifier
// @param data The data
func (client *Client) SendCallSignalingData(callID int32, data []byte) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "sendCallSignalingData",
		"call_id": callID,
		"data":    data,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DiscardCall Discards a call
// @param callID Call identifier
// @param isDisconnected True, if the user was disconnected
// @param duration The call duration, in seconds
// @param isVideo True, if the call was a video call
// @param connectionID Identifier of the connection used during the call
func (client *Client) DiscardCall(callID int32, isDisconnected bool, duration int32, isVideo bool, connectionID *tdlib.JSONInt64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "discardCall",
		"call_id":         callID,
		"is_disconnected": isDisconnected,
		"duration":        duration,
		"is_video":        isVideo,
		"connection_id":   connectionID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SendCallRating Sends a call rating
// @param callID Call identifier
// @param rating Call rating; 1-5
// @param comment An optional user comment if the rating is less than 5
// @param problems List of the exact types of problems with the call, specified by the user
func (client *Client) SendCallRating(callID int32, rating int32, comment string, problems []tdlib.CallProblem) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "sendCallRating",
		"call_id":  callID,
		"rating":   rating,
		"comment":  comment,
		"problems": problems,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SendCallDebugInformation Sends debug information for a call
// @param callID Call identifier
// @param debugInformation Debug information in application-specific format
func (client *Client) SendCallDebugInformation(callID int32, debugInformation string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":             "sendCallDebugInformation",
		"call_id":           callID,
		"debug_information": debugInformation,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetVoiceChatDefaultParticipant Changes default participant identifier, which can be used to join voice chats in a chat
// @param chatID Chat identifier
// @param defaultParticipantID Default group call participant identifier to join the voice chats
func (client *Client) SetVoiceChatDefaultParticipant(chatID int64, defaultParticipantID tdlib.MessageSender) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                  "setVoiceChatDefaultParticipant",
		"chat_id":                chatID,
		"default_participant_id": defaultParticipantID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// StartScheduledGroupCall Starts a scheduled group call
// @param groupCallID Group call identifier
func (client *Client) StartScheduledGroupCall(groupCallID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "startScheduledGroupCall",
		"group_call_id": groupCallID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleGroupCallEnabledStartNotification Toggles whether the current user will receive a notification when the group call will start; scheduled group calls only
// @param groupCallID Group call identifier
// @param enabledStartNotification New value of the enabled_start_notification setting
func (client *Client) ToggleGroupCallEnabledStartNotification(groupCallID int32, enabledStartNotification bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                      "toggleGroupCallEnabledStartNotification",
		"group_call_id":              groupCallID,
		"enabled_start_notification": enabledStartNotification,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleGroupCallScreenSharingIsPaused Pauses or unpauses screen sharing in a joined group call
// @param groupCallID Group call identifier
// @param isPaused True if screen sharing is paused
func (client *Client) ToggleGroupCallScreenSharingIsPaused(groupCallID int32, isPaused bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "toggleGroupCallScreenSharingIsPaused",
		"group_call_id": groupCallID,
		"is_paused":     isPaused,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EndGroupCallScreenSharing Ends screen sharing in a joined group call
// @param groupCallID Group call identifier
func (client *Client) EndGroupCallScreenSharing(groupCallID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "endGroupCallScreenSharing",
		"group_call_id": groupCallID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetGroupCallTitle Sets group call title. Requires groupCall.can_be_managed group call flag
// @param groupCallID Group call identifier
// @param title New group call title; 1-64 characters
func (client *Client) SetGroupCallTitle(groupCallID int32, title string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "setGroupCallTitle",
		"group_call_id": groupCallID,
		"title":         title,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleGroupCallMuteNewParticipants Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_change_mute_new_participants group call flag
// @param groupCallID Group call identifier
// @param muteNewParticipants New value of the mute_new_participants setting
func (client *Client) ToggleGroupCallMuteNewParticipants(groupCallID int32, muteNewParticipants bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                 "toggleGroupCallMuteNewParticipants",
		"group_call_id":         groupCallID,
		"mute_new_participants": muteNewParticipants,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RevokeGroupCallInviteLink Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
// @param groupCallID Group call identifier
func (client *Client) RevokeGroupCallInviteLink(groupCallID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "revokeGroupCallInviteLink",
		"group_call_id": groupCallID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// InviteGroupCallParticipants Invites users to an active group call. Sends a service message of type messageInviteToGroupCall for voice chats
// @param groupCallID Group call identifier
// @param userIDs User identifiers. At most 10 users can be invited simultaneously
func (client *Client) InviteGroupCallParticipants(groupCallID int32, userIDs []int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "inviteGroupCallParticipants",
		"group_call_id": groupCallID,
		"user_ids":      userIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// StartGroupCallRecording Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
// @param groupCallID Group call identifier
// @param title Group call recording title; 0-64 characters
// @param recordVideo Pass true to record a video file instead of an audio file
// @param usePortraitOrientation Pass true to use portrait orientation for video instead of landscape one
func (client *Client) StartGroupCallRecording(groupCallID int32, title string, recordVideo bool, usePortraitOrientation bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                    "startGroupCallRecording",
		"group_call_id":            groupCallID,
		"title":                    title,
		"record_video":             recordVideo,
		"use_portrait_orientation": usePortraitOrientation,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EndGroupCallRecording Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
// @param groupCallID Group call identifier
func (client *Client) EndGroupCallRecording(groupCallID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "endGroupCallRecording",
		"group_call_id": groupCallID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleGroupCallIsMyVideoPaused Toggles whether current user's video is paused
// @param groupCallID Group call identifier
// @param isMyVideoPaused Pass true if the current user's video is paused
func (client *Client) ToggleGroupCallIsMyVideoPaused(groupCallID int32, isMyVideoPaused bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":              "toggleGroupCallIsMyVideoPaused",
		"group_call_id":      groupCallID,
		"is_my_video_paused": isMyVideoPaused,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleGroupCallIsMyVideoEnabled Toggles whether current user's video is enabled
// @param groupCallID Group call identifier
// @param isMyVideoEnabled Pass true if the current user's video is enabled
func (client *Client) ToggleGroupCallIsMyVideoEnabled(groupCallID int32, isMyVideoEnabled bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":               "toggleGroupCallIsMyVideoEnabled",
		"group_call_id":       groupCallID,
		"is_my_video_enabled": isMyVideoEnabled,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetGroupCallParticipantIsSpeaking Informs TDLib that speaking state of a participant of an active group has changed
// @param groupCallID Group call identifier
// @param audioSource Group call participant's synchronization audio source identifier, or 0 for the current user
// @param isSpeaking True, if the user is speaking
func (client *Client) SetGroupCallParticipantIsSpeaking(groupCallID int32, audioSource int32, isSpeaking bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "setGroupCallParticipantIsSpeaking",
		"group_call_id": groupCallID,
		"audio_source":  audioSource,
		"is_speaking":   isSpeaking,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleGroupCallParticipantIsMuted Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
// @param groupCallID Group call identifier
// @param participantID Participant identifier
// @param isMuted Pass true if the user must be muted and false otherwise
func (client *Client) ToggleGroupCallParticipantIsMuted(groupCallID int32, participantID tdlib.MessageSender, isMuted bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "toggleGroupCallParticipantIsMuted",
		"group_call_id":  groupCallID,
		"participant_id": participantID,
		"is_muted":       isMuted,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetGroupCallParticipantVolumeLevel Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with default volume level
// @param groupCallID Group call identifier
// @param participantID Participant identifier
// @param volumeLevel New participant's volume level; 1-20000 in hundreds of percents
func (client *Client) SetGroupCallParticipantVolumeLevel(groupCallID int32, participantID tdlib.MessageSender, volumeLevel int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "setGroupCallParticipantVolumeLevel",
		"group_call_id":  groupCallID,
		"participant_id": participantID,
		"volume_level":   volumeLevel,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleGroupCallParticipantIsHandRaised Toggles whether a group call participant hand is rased
// @param groupCallID Group call identifier
// @param participantID Participant identifier
// @param isHandRaised Pass true if the user's hand should be raised. Only self hand can be raised. Requires groupCall.can_be_managed group call flag to lower other's hand
func (client *Client) ToggleGroupCallParticipantIsHandRaised(groupCallID int32, participantID tdlib.MessageSender, isHandRaised bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "toggleGroupCallParticipantIsHandRaised",
		"group_call_id":  groupCallID,
		"participant_id": participantID,
		"is_hand_raised": isHandRaised,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// LoadGroupCallParticipants Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants has already been loaded
// @param groupCallID Group call identifier. The group call must be previously received through getGroupCall and must be joined or being joined
// @param limit The maximum number of participants to load
func (client *Client) LoadGroupCallParticipants(groupCallID int32, limit int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "loadGroupCallParticipants",
		"group_call_id": groupCallID,
		"limit":         limit,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// LeaveGroupCall Leaves a group call
// @param groupCallID Group call identifier
func (client *Client) LeaveGroupCall(groupCallID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "leaveGroupCall",
		"group_call_id": groupCallID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DiscardGroupCall Discards a group call. Requires groupCall.can_be_managed
// @param groupCallID Group call identifier
func (client *Client) DiscardGroupCall(groupCallID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "discardGroupCall",
		"group_call_id": groupCallID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleMessageSenderIsBlocked Changes the block state of a message sender. Currently, only users and supergroup chats can be blocked
// @param sender Message Sender
// @param isBlocked New value of is_blocked
func (client *Client) ToggleMessageSenderIsBlocked(sender tdlib.MessageSender, isBlocked bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "toggleMessageSenderIsBlocked",
		"sender":     sender,
		"is_blocked": isBlocked,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// BlockMessageSenderFromReplies Blocks an original sender of a message in the Replies chat
// @param messageID The identifier of an incoming message in the Replies chat
// @param deleteMessage Pass true if the message must be deleted
// @param deleteAllMessages Pass true if all messages from the same sender must be deleted
// @param reportSpam Pass true if the sender must be reported to the Telegram moderators
func (client *Client) BlockMessageSenderFromReplies(messageID int64, deleteMessage bool, deleteAllMessages bool, reportSpam bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":               "blockMessageSenderFromReplies",
		"message_id":          messageID,
		"delete_message":      deleteMessage,
		"delete_all_messages": deleteAllMessages,
		"report_spam":         reportSpam,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddContact Adds a user to the contact list or edits an existing contact by their user identifier
// @param contact The contact to add or edit; phone number can be empty and needs to be specified only if known, vCard is ignored
// @param sharePhoneNumber True, if the new contact needs to be allowed to see current user's phone number. A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed. Use the field UserFullInfo.need_phone_number_privacy_exception to check whether the current user needs to be asked to share their phone number
func (client *Client) AddContact(contact *tdlib.Contact, sharePhoneNumber bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":              "addContact",
		"contact":            contact,
		"share_phone_number": sharePhoneNumber,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveContacts Removes users from the contact list
// @param userIDs Identifiers of users to be deleted
func (client *Client) RemoveContacts(userIDs []int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "removeContacts",
		"user_ids": userIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ClearImportedContacts Clears all imported contacts, contact list remains unchanged
func (client *Client) ClearImportedContacts() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "clearImportedContacts",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SharePhoneNumber Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
// @param userID Identifier of the user with whom to share the phone number. The user must be a mutual contact
func (client *Client) SharePhoneNumber(userID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "sharePhoneNumber",
		"user_id": userID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ChangeStickerSet Installs/uninstalls or activates/archives a sticker set
// @param setID Identifier of the sticker set
// @param isInstalled The new value of is_installed
// @param isArchived The new value of is_archived. A sticker set can't be installed and archived simultaneously
func (client *Client) ChangeStickerSet(setID *tdlib.JSONInt64, isInstalled bool, isArchived bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":        "changeStickerSet",
		"set_id":       setID,
		"is_installed": isInstalled,
		"is_archived":  isArchived,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ViewTrendingStickerSets Informs the server that some trending sticker sets have been viewed by the user
// @param stickerSetIDs Identifiers of viewed trending sticker sets
func (client *Client) ViewTrendingStickerSets(stickerSetIDs []tdlib.JSONInt64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "viewTrendingStickerSets",
		"sticker_set_ids": stickerSetIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ReorderInstalledStickerSets Changes the order of installed sticker sets
// @param isMasks Pass true to change the order of mask sticker sets; pass false to change the order of ordinary sticker sets
// @param stickerSetIDs Identifiers of installed sticker sets in the new correct order
func (client *Client) ReorderInstalledStickerSets(isMasks bool, stickerSetIDs []tdlib.JSONInt64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "reorderInstalledStickerSets",
		"is_masks":        isMasks,
		"sticker_set_ids": stickerSetIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveRecentSticker Removes a sticker from the list of recently used stickers
// @param isAttached Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers
// @param sticker Sticker file to delete
func (client *Client) RemoveRecentSticker(isAttached bool, sticker tdlib.InputFile) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":       "removeRecentSticker",
		"is_attached": isAttached,
		"sticker":     sticker,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ClearRecentStickers Clears the list of recently used stickers
// @param isAttached Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers
func (client *Client) ClearRecentStickers(isAttached bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":       "clearRecentStickers",
		"is_attached": isAttached,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddFavoriteSticker Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
// @param sticker Sticker file to add
func (client *Client) AddFavoriteSticker(sticker tdlib.InputFile) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "addFavoriteSticker",
		"sticker": sticker,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveFavoriteSticker Removes a sticker from the list of favorite stickers
// @param sticker Sticker file to delete from the list
func (client *Client) RemoveFavoriteSticker(sticker tdlib.InputFile) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "removeFavoriteSticker",
		"sticker": sticker,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddSavedAnimation Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
// @param animation The animation file to be added. Only animations known to the server (i.e. successfully sent via a message) can be added to the list
func (client *Client) AddSavedAnimation(animation tdlib.InputFile) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "addSavedAnimation",
		"animation": animation,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveSavedAnimation Removes an animation from the list of saved animations
// @param animation Animation file to be removed
func (client *Client) RemoveSavedAnimation(animation tdlib.InputFile) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":     "removeSavedAnimation",
		"animation": animation,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveRecentHashtag Removes a hashtag from the list of recently used hashtags
// @param hashtag Hashtag to delete
func (client *Client) RemoveRecentHashtag(hashtag string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "removeRecentHashtag",
		"hashtag": hashtag,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetProfilePhoto Changes a profile photo for the current user
// @param photo Profile photo to set
func (client *Client) SetProfilePhoto(photo tdlib.InputChatPhoto) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "setProfilePhoto",
		"photo": photo,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteProfilePhoto Deletes a profile photo
// @param profilePhotoID Identifier of the profile photo to delete
func (client *Client) DeleteProfilePhoto(profilePhotoID *tdlib.JSONInt64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":            "deleteProfilePhoto",
		"profile_photo_id": profilePhotoID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetName Changes the first and last name of the current user
// @param firstName The new value of the first name for the current user; 1-64 characters
// @param lastName The new value of the optional last name for the current user; 0-64 characters
func (client *Client) SetName(firstName string, lastName string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "setName",
		"first_name": firstName,
		"last_name":  lastName,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetBio Changes the bio of the current user
// @param bio The new value of the user bio; 0-70 characters without line feeds
func (client *Client) SetBio(bio string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "setBio",
		"bio":   bio,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetUsername Changes the username of the current user
// @param username The new value of the username. Use an empty string to remove the username
func (client *Client) SetUsername(username string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "setUsername",
		"username": username,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetLocation Changes the location of the current user. Needs to be called if GetOption("is_location_visible") is true and location changes for more than 1 kilometer
// @param location The new location of the user
func (client *Client) SetLocation(location *tdlib.Location) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "setLocation",
		"location": location,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckChangePhoneNumberCode Checks the authentication code sent to confirm a new phone number of the user
// @param code Verification code received by SMS, phone call or flash call
func (client *Client) CheckChangePhoneNumberCode(code string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "checkChangePhoneNumberCode",
		"code":  code,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetCommands Sets the list of commands supported by the bot for the given user scope and language; for bots only
// @param scope The scope to which the commands are relevant
// @param languageCode A two-letter ISO 639-1 country code. If empty, the commands will be applied to all users from the given scope, for which language there are no dedicated commands
// @param commands List of the bot's commands
func (client *Client) SetCommands(scope tdlib.BotCommandScope, languageCode string, commands []tdlib.BotCommand) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "setCommands",
		"scope":         scope,
		"language_code": languageCode,
		"commands":      commands,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteCommands Deletes commands supported by the bot for the given user scope and language; for bots only
// @param scope The scope to which the commands are relevant
// @param languageCode A two-letter ISO 639-1 country code or an empty string
func (client *Client) DeleteCommands(scope tdlib.BotCommandScope, languageCode string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "deleteCommands",
		"scope":         scope,
		"language_code": languageCode,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// TerminateSession Terminates a session of the current user
// @param sessionID Session identifier
func (client *Client) TerminateSession(sessionID *tdlib.JSONInt64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "terminateSession",
		"session_id": sessionID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// TerminateAllOtherSessions Terminates all other sessions of the current user
func (client *Client) TerminateAllOtherSessions() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "terminateAllOtherSessions",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DisconnectWebsite Disconnects website from the current user's Telegram account
// @param websiteID Website identifier
func (client *Client) DisconnectWebsite(websiteID *tdlib.JSONInt64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "disconnectWebsite",
		"website_id": websiteID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DisconnectAllWebsites Disconnects all websites from the current user's Telegram account
func (client *Client) DisconnectAllWebsites() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "disconnectAllWebsites",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetSupergroupUsername Changes the username of a supergroup or channel, requires owner privileges in the supergroup or channel
// @param supergroupID Identifier of the supergroup or channel
// @param username New value of the username. Use an empty string to remove the username
func (client *Client) SetSupergroupUsername(supergroupID int64, username string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "setSupergroupUsername",
		"supergroup_id": supergroupID,
		"username":      username,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetSupergroupStickerSet Changes the sticker set of a supergroup; requires can_change_info administrator right
// @param supergroupID Identifier of the supergroup
// @param stickerSetID New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set
func (client *Client) SetSupergroupStickerSet(supergroupID int64, stickerSetID *tdlib.JSONInt64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "setSupergroupStickerSet",
		"supergroup_id":  supergroupID,
		"sticker_set_id": stickerSetID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleSupergroupSignMessages Toggles sender signatures messages sent in a channel; requires can_change_info administrator right
// @param supergroupID Identifier of the channel
// @param signMessages New value of sign_messages
func (client *Client) ToggleSupergroupSignMessages(supergroupID int64, signMessages bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "toggleSupergroupSignMessages",
		"supergroup_id": supergroupID,
		"sign_messages": signMessages,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleSupergroupIsAllHistoryAvailable Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
// @param supergroupID The identifier of the supergroup
// @param isAllHistoryAvailable The new value of is_all_history_available
func (client *Client) ToggleSupergroupIsAllHistoryAvailable(supergroupID int64, isAllHistoryAvailable bool) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                    "toggleSupergroupIsAllHistoryAvailable",
		"supergroup_id":            supergroupID,
		"is_all_history_available": isAllHistoryAvailable,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ToggleSupergroupIsBroadcastGroup Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
// @param supergroupID Identifier of the supergroup
func (client *Client) ToggleSupergroupIsBroadcastGroup(supergroupID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "toggleSupergroupIsBroadcastGroup",
		"supergroup_id": supergroupID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ReportSupergroupSpam Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup
// @param supergroupID Supergroup identifier
// @param userID User identifier
// @param messageIDs Identifiers of messages sent in the supergroup by the user. This list must be non-empty
func (client *Client) ReportSupergroupSpam(supergroupID int64, userID int64, messageIDs []int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "reportSupergroupSpam",
		"supergroup_id": supergroupID,
		"user_id":       userID,
		"message_ids":   messageIDs,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CloseSecretChat Closes a secret chat, effectively transferring its state to secretChatStateClosed
// @param secretChatID Secret chat identifier
func (client *Client) CloseSecretChat(secretChatID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":          "closeSecretChat",
		"secret_chat_id": secretChatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteSavedOrderInfo Deletes saved order info
func (client *Client) DeleteSavedOrderInfo() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "deleteSavedOrderInfo",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteSavedCredentials Deletes saved credentials for all payment provider bots
func (client *Client) DeleteSavedCredentials() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "deleteSavedCredentials",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveBackground Removes background from the list of installed backgrounds
// @param backgroundID The background identifier
func (client *Client) RemoveBackground(backgroundID *tdlib.JSONInt64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":         "removeBackground",
		"background_id": backgroundID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ResetBackgrounds Resets list of installed backgrounds to its default value
func (client *Client) ResetBackgrounds() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "resetBackgrounds",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SynchronizeLanguagePack Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method shouldn't be called explicitly for the current used/base language packs. Can be called before authorization
// @param languagePackID Language pack identifier
func (client *Client) SynchronizeLanguagePack(languagePackID string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":            "synchronizeLanguagePack",
		"language_pack_id": languagePackID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddCustomServerLanguagePack Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
// @param languagePackID Identifier of a language pack to be added; may be different from a name that is used in an "https://t.me/setlanguage/" link
func (client *Client) AddCustomServerLanguagePack(languagePackID string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":            "addCustomServerLanguagePack",
		"language_pack_id": languagePackID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetCustomLanguagePack Adds or changes a custom local language pack to the current localization target
// @param info Information about the language pack. Language pack ID must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization
// @param strings Strings of the new language pack
func (client *Client) SetCustomLanguagePack(info *tdlib.LanguagePackInfo, strings []tdlib.LanguagePackString) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "setCustomLanguagePack",
		"info":    info,
		"strings": strings,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EditCustomLanguagePackInfo Edits information about a custom local language pack in the current localization target. Can be called before authorization
// @param info New information about the custom local language pack
func (client *Client) EditCustomLanguagePackInfo(info *tdlib.LanguagePackInfo) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "editCustomLanguagePackInfo",
		"info":  info,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetCustomLanguagePackString Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
// @param languagePackID Identifier of a previously added custom local language pack in the current localization target
// @param newString New language pack string
func (client *Client) SetCustomLanguagePackString(languagePackID string, newString *tdlib.LanguagePackString) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":            "setCustomLanguagePackString",
		"language_pack_id": languagePackID,
		"new_string":       newString,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteLanguagePack Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization
// @param languagePackID Identifier of the language pack to delete
func (client *Client) DeleteLanguagePack(languagePackID string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":            "deleteLanguagePack",
		"language_pack_id": languagePackID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ProcessPushNotification Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
// @param payload JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added
func (client *Client) ProcessPushNotification(payload string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "processPushNotification",
		"payload": payload,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetUserPrivacySettingRules Changes user privacy settings
// @param setting The privacy setting
// @param rules The new privacy rules
func (client *Client) SetUserPrivacySettingRules(setting tdlib.UserPrivacySetting, rules *tdlib.UserPrivacySettingRules) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "setUserPrivacySettingRules",
		"setting": setting,
		"rules":   rules,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetOption Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
// @param name The name of the option
// @param value The new value of the option
func (client *Client) SetOption(name string, value tdlib.OptionValue) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "setOption",
		"name":  name,
		"value": value,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetAccountTTL Changes the period of inactivity after which the account of the current user will automatically be deleted
// @param tTL New account TTL
func (client *Client) SetAccountTTL(tTL *tdlib.AccountTTL) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "setAccountTtl",
		"ttl":   tTL,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeleteAccount Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is authorizationStateWaitPassword
// @param reason The reason why the account was deleted; optional
func (client *Client) DeleteAccount(reason string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":  "deleteAccount",
		"reason": reason,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveChatActionBar Removes a chat action bar without any other action
// @param chatID Chat identifier
func (client *Client) RemoveChatActionBar(chatID int64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "removeChatActionBar",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ReportChat Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if this is a private chat with a bot, a private chat with a user sharing their location, a supergroup, or a channel, since other chats can't be checked by moderators
// @param chatID Chat identifier
// @param messageIDs Identifiers of reported messages, if any
// @param reason The reason for reporting the chat
// @param text Additional report details; 0-1024 characters
func (client *Client) ReportChat(chatID int64, messageIDs []int64, reason tdlib.ChatReportReason, text string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":       "reportChat",
		"chat_id":     chatID,
		"message_ids": messageIDs,
		"reason":      reason,
		"text":        text,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ReportChatPhoto Reports a chat photo to the Telegram moderators. A chat photo can be reported only if this is a private chat with a bot, a private chat with a user sharing their location, a supergroup, or a channel, since other chats can't be checked by moderators
// @param chatID Chat identifier
// @param fileID Identifier of the photo to report. Only full photos from chatPhoto can be reported
// @param reason The reason for reporting the chat photo
// @param text Additional report details; 0-1024 characters
func (client *Client) ReportChatPhoto(chatID int64, fileID int32, reason tdlib.ChatReportReason, text string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "reportChatPhoto",
		"chat_id": chatID,
		"file_id": fileID,
		"reason":  reason,
		"text":    text,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetNetworkType Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it should be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
// @param typeParam The new network type. By default, networkTypeOther
func (client *Client) SetNetworkType(typeParam tdlib.NetworkType) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "setNetworkType",
		"type":  typeParam,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddNetworkStatistics Adds the specified data to data usage statistics. Can be called before authorization
// @param entry The network statistics entry with the data to be added to statistics
func (client *Client) AddNetworkStatistics(entry tdlib.NetworkStatisticsEntry) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "addNetworkStatistics",
		"entry": entry,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// ResetNetworkStatistics Resets all network data usage statistics to zero. Can be called before authorization
func (client *Client) ResetNetworkStatistics() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "resetNetworkStatistics",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetAutoDownloadSettings Sets auto-download settings
// @param settings New user auto-download settings
// @param typeParam Type of the network for which the new settings are relevant
func (client *Client) SetAutoDownloadSettings(settings *tdlib.AutoDownloadSettings, typeParam tdlib.NetworkType) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "setAutoDownloadSettings",
		"settings": settings,
		"type":     typeParam,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DeletePassportElement Deletes a Telegram Passport element
// @param typeParam Element type
func (client *Client) DeletePassportElement(typeParam tdlib.PassportElementType) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "deletePassportElement",
		"type":  typeParam,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetPassportElementErrors Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
// @param userID User identifier
// @param errors The errors
func (client *Client) SetPassportElementErrors(userID int64, errors []tdlib.InputPassportElementError) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "setPassportElementErrors",
		"user_id": userID,
		"errors":  errors,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckPhoneNumberVerificationCode Checks the phone number verification code for Telegram Passport
// @param code Verification code
func (client *Client) CheckPhoneNumberVerificationCode(code string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "checkPhoneNumberVerificationCode",
		"code":  code,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckEmailAddressVerificationCode Checks the email address verification code for Telegram Passport
// @param code Verification code
func (client *Client) CheckEmailAddressVerificationCode(code string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "checkEmailAddressVerificationCode",
		"code":  code,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SendPassportAuthorizationForm Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
// @param autorizationFormID Authorization form identifier
// @param typeParams Types of Telegram Passport elements chosen by user to complete the authorization form
func (client *Client) SendPassportAuthorizationForm(autorizationFormID int32, typeParams []tdlib.PassportElementType) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                "sendPassportAuthorizationForm",
		"autorization_form_id": autorizationFormID,
		"types":                typeParams,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// CheckPhoneNumberConfirmationCode Checks phone number confirmation code
// @param code The phone number confirmation code
func (client *Client) CheckPhoneNumberConfirmationCode(code string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "checkPhoneNumberConfirmationCode",
		"code":  code,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetBotUpdatesStatus Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
// @param pendingUpdateCount The number of pending updates
// @param errorMessage The last error message
func (client *Client) SetBotUpdatesStatus(pendingUpdateCount int32, errorMessage string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":                "setBotUpdatesStatus",
		"pending_update_count": pendingUpdateCount,
		"error_message":        errorMessage,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetStickerPositionInSet Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
// @param sticker Sticker
// @param position New position of the sticker in the set, zero-based
func (client *Client) SetStickerPositionInSet(sticker tdlib.InputFile, position int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "setStickerPositionInSet",
		"sticker":  sticker,
		"position": position,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveStickerFromSet Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
// @param sticker Sticker
func (client *Client) RemoveStickerFromSet(sticker tdlib.InputFile) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "removeStickerFromSet",
		"sticker": sticker,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AcceptTermsOfService Accepts Telegram terms of services
// @param termsOfServiceID Terms of service identifier
func (client *Client) AcceptTermsOfService(termsOfServiceID string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":               "acceptTermsOfService",
		"terms_of_service_id": termsOfServiceID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AnswerCustomQuery Answers a custom query; for bots only
// @param customQueryID Identifier of a custom query
// @param data JSON-serialized answer to the query
func (client *Client) AnswerCustomQuery(customQueryID *tdlib.JSONInt64, data string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "answerCustomQuery",
		"custom_query_id": customQueryID,
		"data":            data,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetAlarm Succeeds after a specified amount of time has passed. Can be called before initialization
// @param seconds Number of seconds before the function returns
func (client *Client) SetAlarm(seconds float64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "setAlarm",
		"seconds": seconds,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SaveApplicationLogEvent Saves application log event on the server. Can be called before authorization
// @param typeParam Event type
// @param chatID Optional chat identifier, associated with the event
// @param data The log event data
func (client *Client) SaveApplicationLogEvent(typeParam string, chatID int64, data tdlib.JsonValue) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "saveApplicationLogEvent",
		"type":    typeParam,
		"chat_id": chatID,
		"data":    data,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// EnableProxy Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
// @param proxyID Proxy identifier
func (client *Client) EnableProxy(proxyID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "enableProxy",
		"proxy_id": proxyID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// DisableProxy Disables the currently enabled proxy. Can be called before authorization
func (client *Client) DisableProxy() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "disableProxy",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// RemoveProxy Removes a proxy server. Can be called before authorization
// @param proxyID Proxy identifier
func (client *Client) RemoveProxy(proxyID int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":    "removeProxy",
		"proxy_id": proxyID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetLogStream Sets new log stream for internal logging of TDLib. Can be called synchronously
// @param logStream New log stream
func (client *Client) SetLogStream(logStream tdlib.LogStream) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":      "setLogStream",
		"log_stream": logStream,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetLogVerbosityLevel Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
// @param newVerbosityLevel New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging
func (client *Client) SetLogVerbosityLevel(newVerbosityLevel int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":               "setLogVerbosityLevel",
		"new_verbosity_level": newVerbosityLevel,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// SetLogTagVerbosityLevel Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
// @param tag Logging tag to change verbosity level
// @param newVerbosityLevel New verbosity level; 1-1024
func (client *Client) SetLogTagVerbosityLevel(tag string, newVerbosityLevel int32) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":               "setLogTagVerbosityLevel",
		"tag":                 tag,
		"new_verbosity_level": newVerbosityLevel,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// AddLogMessage Adds a message to TDLib internal log. Can be called synchronously
// @param verbosityLevel The minimum verbosity level needed for the message to be logged; 0-1023
// @param text Text of a message to log
func (client *Client) AddLogMessage(verbosityLevel int32, text string) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":           "addLogMessage",
		"verbosity_level": verbosityLevel,
		"text":            text,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// TestCallEmpty Does nothing; for testing only. This is an offline method. Can be called before authorization
func (client *Client) TestCallEmpty() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "testCallEmpty",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// TestNetwork Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
func (client *Client) TestNetwork() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "testNetwork",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// TestProxy Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
// @param server Proxy server IP address
// @param port Proxy server port
// @param typeParam Proxy type
// @param dcID Identifier of a datacenter, with which to test connection
// @param timeout The maximum overall timeout for the request
func (client *Client) TestProxy(server string, port int32, typeParam tdlib.ProxyType, dcID int32, timeout float64) (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type":   "testProxy",
		"server":  server,
		"port":    port,
		"type":    typeParam,
		"dc_id":   dcID,
		"timeout": timeout,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}

// TestGetDifference Forces an updates.getDifference call to the Telegram servers; for testing only
func (client *Client) TestGetDifference() (*tdlib.Ok, error) {
	result, err := client.SendAndCatch(tdlib.UpdateData{
		"@type": "testGetDifference",
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, tdlib.RequestError{Code: int(result.Data["code"].(float64)), Message: result.Data["message"].(string)}
	}

	var ok tdlib.Ok
	err = json.Unmarshal(result.Raw, &ok)
	return &ok, err

}
