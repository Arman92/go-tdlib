// AUTOGENERATED - DO NOT EDIT

package tdlib

import (
	"encoding/json"
	"fmt"
)

// HttpURL Contains an HTTP URL
type HttpURL struct {
	tdCommon
	URL string `json:"url"` // The URL
}

// MessageType return the string telegram-type of HttpURL
func (httpURL *HttpURL) MessageType() string {
	return "httpUrl"
}

// NewHttpURL creates a new HttpURL
//
// @param uRL The URL
func NewHttpURL(uRL string) *HttpURL {
	httpURLTemp := HttpURL{
		tdCommon: tdCommon{Type: "httpUrl"},
		URL:      uRL,
	}

	return &httpURLTemp
}

// GetLoginURL Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl. Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
// @param chatID Chat identifier of the message with the button
// @param messageID Message identifier of the message with the button
// @param buttonID Button identifier
// @param allowWriteAccess True, if the user allowed the bot to send them messages
func (client *Client) GetLoginURL(chatID int64, messageID int64, buttonID int32, allowWriteAccess bool) (*HttpURL, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":              "getLoginUrl",
		"chat_id":            chatID,
		"message_id":         messageID,
		"button_id":          buttonID,
		"allow_write_access": allowWriteAccess,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var httpURL HttpURL
	err = json.Unmarshal(result.Raw, &httpURL)
	return &httpURL, err

}
