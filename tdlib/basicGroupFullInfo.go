// AUTOGENERATED - DO NOT EDIT

package tdlib

import (
	"encoding/json"
	"fmt"
)

// BasicGroupFullInfo Contains full information about a basic group
type BasicGroupFullInfo struct {
	tdCommon
	Photo         *ChatPhoto   `json:"photo"`           // Chat photo; may be null
	Description   string       `json:"description"`     // Group description
	CreatorUserID int32        `json:"creator_user_id"` // User identifier of the creator of the group; 0 if unknown
	Members       []ChatMember `json:"members"`         // Group members
	InviteLink    string       `json:"invite_link"`     // Invite link for this group; available only after it has been generated at least once and only for the group creator
}

// MessageType return the string telegram-type of BasicGroupFullInfo
func (basicGroupFullInfo *BasicGroupFullInfo) MessageType() string {
	return "basicGroupFullInfo"
}

// NewBasicGroupFullInfo creates a new BasicGroupFullInfo
//
// @param photo Chat photo; may be null
// @param description Group description
// @param creatorUserID User identifier of the creator of the group; 0 if unknown
// @param members Group members
// @param inviteLink Invite link for this group; available only after it has been generated at least once and only for the group creator
func NewBasicGroupFullInfo(photo *ChatPhoto, description string, creatorUserID int32, members []ChatMember, inviteLink string) *BasicGroupFullInfo {
	basicGroupFullInfoTemp := BasicGroupFullInfo{
		tdCommon:      tdCommon{Type: "basicGroupFullInfo"},
		Photo:         photo,
		Description:   description,
		CreatorUserID: creatorUserID,
		Members:       members,
		InviteLink:    inviteLink,
	}

	return &basicGroupFullInfoTemp
}

// GetBasicGroupFullInfo Returns full information about a basic group by its identifier
// @param basicGroupID Basic group identifier
func (client *Client) GetBasicGroupFullInfo(basicGroupID int32) (*BasicGroupFullInfo, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":          "getBasicGroupFullInfo",
		"basic_group_id": basicGroupID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var basicGroupFullInfo BasicGroupFullInfo
	err = json.Unmarshal(result.Raw, &basicGroupFullInfo)
	return &basicGroupFullInfo, err

}
