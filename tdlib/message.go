// AUTOGENERATED - DO NOT EDIT

package tdlib

import (
	"encoding/json"
	"fmt"
)

// Message Describes a message
type Message struct {
	tdCommon
	ID                      int64                   `json:"id"`                           // Message identifier; unique for the chat to which the message belongs
	Sender                  MessageSender           `json:"sender"`                       // The sender of the message
	ChatID                  int64                   `json:"chat_id"`                      // Chat identifier
	SendingState            MessageSendingState     `json:"sending_state"`                // Information about the sending state of the message; may be null
	SchedulingState         MessageSchedulingState  `json:"scheduling_state"`             // Information about the scheduling state of the message; may be null
	IsOutgoing              bool                    `json:"is_outgoing"`                  // True, if the message is outgoing
	IsPinned                bool                    `json:"is_pinned"`                    // True, if the message is pinned
	CanBeEdited             bool                    `json:"can_be_edited"`                // True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
	CanBeForwarded          bool                    `json:"can_be_forwarded"`             // True, if the message can be forwarded
	CanBeDeletedOnlyForSelf bool                    `json:"can_be_deleted_only_for_self"` // True, if the message can be deleted only for the current user while other users will continue to see it
	CanBeDeletedForAllUsers bool                    `json:"can_be_deleted_for_all_users"` // True, if the message can be deleted for all users
	CanGetStatistics        bool                    `json:"can_get_statistics"`           // True, if the message statistics are available
	CanGetMessageThread     bool                    `json:"can_get_message_thread"`       // True, if the message thread info is available
	IsChannelPost           bool                    `json:"is_channel_post"`              // True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
	ContainsUnreadMention   bool                    `json:"contains_unread_mention"`      // True, if the message contains an unread mention for the current user
	Date                    int32                   `json:"date"`                         // Point in time (Unix timestamp) when the message was sent
	EditDate                int32                   `json:"edit_date"`                    // Point in time (Unix timestamp) when the message was last edited
	ForwardInfo             *MessageForwardInfo     `json:"forward_info"`                 // Information about the initial message sender; may be null
	InteractionInfo         *MessageInteractionInfo `json:"interaction_info"`             // Information about interactions with the message; may be null
	ReplyInChatID           int64                   `json:"reply_in_chat_id"`             // If non-zero, the identifier of the chat to which the replied message belongs; Currently, only messages in the Replies chat can have different reply_in_chat_id and chat_id
	ReplyToMessageID        int64                   `json:"reply_to_message_id"`          // If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
	MessageThreadID         int64                   `json:"message_thread_id"`            // If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
	TTL                     int32                   `json:"ttl"`                          // For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
	TTLExpiresIn            float64                 `json:"ttl_expires_in"`               // Time left before the message expires, in seconds
	ViaBotUserID            int32                   `json:"via_bot_user_id"`              // If non-zero, the user identifier of the bot through which this message was sent
	AuthorSignature         string                  `json:"author_signature"`             // For channel posts and anonymous group messages, optional author signature
	MediaAlbumID            JSONInt64               `json:"media_album_id"`               // Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums
	RestrictionReason       string                  `json:"restriction_reason"`           // If non-empty, contains a human-readable description of the reason why access to this message must be restricted
	Content                 MessageContent          `json:"content"`                      // Content of the message
	ReplyMarkup             ReplyMarkup             `json:"reply_markup"`                 // Reply markup for the message; may be null
}

// MessageType return the string telegram-type of Message
func (message *Message) MessageType() string {
	return "message"
}

// NewMessage creates a new Message
//
// @param iD Message identifier; unique for the chat to which the message belongs
// @param sender The sender of the message
// @param chatID Chat identifier
// @param sendingState Information about the sending state of the message; may be null
// @param schedulingState Information about the scheduling state of the message; may be null
// @param isOutgoing True, if the message is outgoing
// @param isPinned True, if the message is pinned
// @param canBeEdited True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
// @param canBeForwarded True, if the message can be forwarded
// @param canBeDeletedOnlyForSelf True, if the message can be deleted only for the current user while other users will continue to see it
// @param canBeDeletedForAllUsers True, if the message can be deleted for all users
// @param canGetStatistics True, if the message statistics are available
// @param canGetMessageThread True, if the message thread info is available
// @param isChannelPost True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
// @param containsUnreadMention True, if the message contains an unread mention for the current user
// @param date Point in time (Unix timestamp) when the message was sent
// @param editDate Point in time (Unix timestamp) when the message was last edited
// @param forwardInfo Information about the initial message sender; may be null
// @param interactionInfo Information about interactions with the message; may be null
// @param replyInChatID If non-zero, the identifier of the chat to which the replied message belongs; Currently, only messages in the Replies chat can have different reply_in_chat_id and chat_id
// @param replyToMessageID If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
// @param messageThreadID If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
// @param tTL For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
// @param tTLExpiresIn Time left before the message expires, in seconds
// @param viaBotUserID If non-zero, the user identifier of the bot through which this message was sent
// @param authorSignature For channel posts and anonymous group messages, optional author signature
// @param mediaAlbumID Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums
// @param restrictionReason If non-empty, contains a human-readable description of the reason why access to this message must be restricted
// @param content Content of the message
// @param replyMarkup Reply markup for the message; may be null
func NewMessage(iD int64, sender MessageSender, chatID int64, sendingState MessageSendingState, schedulingState MessageSchedulingState, isOutgoing bool, isPinned bool, canBeEdited bool, canBeForwarded bool, canBeDeletedOnlyForSelf bool, canBeDeletedForAllUsers bool, canGetStatistics bool, canGetMessageThread bool, isChannelPost bool, containsUnreadMention bool, date int32, editDate int32, forwardInfo *MessageForwardInfo, interactionInfo *MessageInteractionInfo, replyInChatID int64, replyToMessageID int64, messageThreadID int64, tTL int32, tTLExpiresIn float64, viaBotUserID int32, authorSignature string, mediaAlbumID JSONInt64, restrictionReason string, content MessageContent, replyMarkup ReplyMarkup) *Message {
	messageTemp := Message{
		tdCommon:                tdCommon{Type: "message"},
		ID:                      iD,
		Sender:                  sender,
		ChatID:                  chatID,
		SendingState:            sendingState,
		SchedulingState:         schedulingState,
		IsOutgoing:              isOutgoing,
		IsPinned:                isPinned,
		CanBeEdited:             canBeEdited,
		CanBeForwarded:          canBeForwarded,
		CanBeDeletedOnlyForSelf: canBeDeletedOnlyForSelf,
		CanBeDeletedForAllUsers: canBeDeletedForAllUsers,
		CanGetStatistics:        canGetStatistics,
		CanGetMessageThread:     canGetMessageThread,
		IsChannelPost:           isChannelPost,
		ContainsUnreadMention:   containsUnreadMention,
		Date:                    date,
		EditDate:                editDate,
		ForwardInfo:             forwardInfo,
		InteractionInfo:         interactionInfo,
		ReplyInChatID:           replyInChatID,
		ReplyToMessageID:        replyToMessageID,
		MessageThreadID:         messageThreadID,
		TTL:                     tTL,
		TTLExpiresIn:            tTLExpiresIn,
		ViaBotUserID:            viaBotUserID,
		AuthorSignature:         authorSignature,
		MediaAlbumID:            mediaAlbumID,
		RestrictionReason:       restrictionReason,
		Content:                 content,
		ReplyMarkup:             replyMarkup,
	}

	return &messageTemp
}

// UnmarshalJSON unmarshal to json
func (message *Message) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                      int64                   `json:"id"`                           // Message identifier; unique for the chat to which the message belongs
		ChatID                  int64                   `json:"chat_id"`                      // Chat identifier
		IsOutgoing              bool                    `json:"is_outgoing"`                  // True, if the message is outgoing
		IsPinned                bool                    `json:"is_pinned"`                    // True, if the message is pinned
		CanBeEdited             bool                    `json:"can_be_edited"`                // True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
		CanBeForwarded          bool                    `json:"can_be_forwarded"`             // True, if the message can be forwarded
		CanBeDeletedOnlyForSelf bool                    `json:"can_be_deleted_only_for_self"` // True, if the message can be deleted only for the current user while other users will continue to see it
		CanBeDeletedForAllUsers bool                    `json:"can_be_deleted_for_all_users"` // True, if the message can be deleted for all users
		CanGetStatistics        bool                    `json:"can_get_statistics"`           // True, if the message statistics are available
		CanGetMessageThread     bool                    `json:"can_get_message_thread"`       // True, if the message thread info is available
		IsChannelPost           bool                    `json:"is_channel_post"`              // True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
		ContainsUnreadMention   bool                    `json:"contains_unread_mention"`      // True, if the message contains an unread mention for the current user
		Date                    int32                   `json:"date"`                         // Point in time (Unix timestamp) when the message was sent
		EditDate                int32                   `json:"edit_date"`                    // Point in time (Unix timestamp) when the message was last edited
		ForwardInfo             *MessageForwardInfo     `json:"forward_info"`                 // Information about the initial message sender; may be null
		InteractionInfo         *MessageInteractionInfo `json:"interaction_info"`             // Information about interactions with the message; may be null
		ReplyInChatID           int64                   `json:"reply_in_chat_id"`             // If non-zero, the identifier of the chat to which the replied message belongs; Currently, only messages in the Replies chat can have different reply_in_chat_id and chat_id
		ReplyToMessageID        int64                   `json:"reply_to_message_id"`          // If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
		MessageThreadID         int64                   `json:"message_thread_id"`            // If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
		TTL                     int32                   `json:"ttl"`                          // For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
		TTLExpiresIn            float64                 `json:"ttl_expires_in"`               // Time left before the message expires, in seconds
		ViaBotUserID            int32                   `json:"via_bot_user_id"`              // If non-zero, the user identifier of the bot through which this message was sent
		AuthorSignature         string                  `json:"author_signature"`             // For channel posts and anonymous group messages, optional author signature
		MediaAlbumID            JSONInt64               `json:"media_album_id"`               // Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums
		RestrictionReason       string                  `json:"restriction_reason"`           // If non-empty, contains a human-readable description of the reason why access to this message must be restricted

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	message.tdCommon = tempObj.tdCommon
	message.ID = tempObj.ID
	message.ChatID = tempObj.ChatID
	message.IsOutgoing = tempObj.IsOutgoing
	message.IsPinned = tempObj.IsPinned
	message.CanBeEdited = tempObj.CanBeEdited
	message.CanBeForwarded = tempObj.CanBeForwarded
	message.CanBeDeletedOnlyForSelf = tempObj.CanBeDeletedOnlyForSelf
	message.CanBeDeletedForAllUsers = tempObj.CanBeDeletedForAllUsers
	message.CanGetStatistics = tempObj.CanGetStatistics
	message.CanGetMessageThread = tempObj.CanGetMessageThread
	message.IsChannelPost = tempObj.IsChannelPost
	message.ContainsUnreadMention = tempObj.ContainsUnreadMention
	message.Date = tempObj.Date
	message.EditDate = tempObj.EditDate
	message.ForwardInfo = tempObj.ForwardInfo
	message.InteractionInfo = tempObj.InteractionInfo
	message.ReplyInChatID = tempObj.ReplyInChatID
	message.ReplyToMessageID = tempObj.ReplyToMessageID
	message.MessageThreadID = tempObj.MessageThreadID
	message.TTL = tempObj.TTL
	message.TTLExpiresIn = tempObj.TTLExpiresIn
	message.ViaBotUserID = tempObj.ViaBotUserID
	message.AuthorSignature = tempObj.AuthorSignature
	message.MediaAlbumID = tempObj.MediaAlbumID
	message.RestrictionReason = tempObj.RestrictionReason

	fieldSender, _ := unmarshalMessageSender(objMap["sender"])
	message.Sender = fieldSender

	fieldSendingState, _ := unmarshalMessageSendingState(objMap["sending_state"])
	message.SendingState = fieldSendingState

	fieldSchedulingState, _ := unmarshalMessageSchedulingState(objMap["scheduling_state"])
	message.SchedulingState = fieldSchedulingState

	fieldContent, _ := unmarshalMessageContent(objMap["content"])
	message.Content = fieldContent

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	message.ReplyMarkup = fieldReplyMarkup

	return nil
}

// GetMessage Returns information about a message
// @param chatID Identifier of the chat the message belongs to
// @param messageID Identifier of the message to get
func (client *Client) GetMessage(chatID int64, messageID int64) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":      "getMessage",
		"chat_id":    chatID,
		"message_id": messageID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// GetMessageLocally Returns information about a message, if it is available locally without sending network request. This is an offline request
// @param chatID Identifier of the chat the message belongs to
// @param messageID Identifier of the message to get
func (client *Client) GetMessageLocally(chatID int64, messageID int64) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":      "getMessageLocally",
		"chat_id":    chatID,
		"message_id": messageID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// GetRepliedMessage Returns information about a message that is replied by a given message. Also returns the pinned message, the game message, and the invoice message for messages of the types messagePinMessage, messageGameScore, and messagePaymentSuccessful respectively
// @param chatID Identifier of the chat the message belongs to
// @param messageID Identifier of the message reply to which to get
func (client *Client) GetRepliedMessage(chatID int64, messageID int64) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":      "getRepliedMessage",
		"chat_id":    chatID,
		"message_id": messageID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// GetChatPinnedMessage Returns information about a newest pinned message in the chat
// @param chatID Identifier of the chat the message belongs to
func (client *Client) GetChatPinnedMessage(chatID int64) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":   "getChatPinnedMessage",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var message Message
	err = json.Unmarshal(result.Raw, &message)
	return &message, err

}

// GetCallbackQueryMessage Returns information about a message with the callback button that originated a callback query; for bots only
// @param chatID Identifier of the chat the message belongs to
// @param messageID Message identifier
// @param callbackQueryID Identifier of the callback query
func (client *Client) GetCallbackQueryMessage(chatID int64, messageID int64, callbackQueryID JSONInt64) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":             "getCallbackQueryMessage",
		"chat_id":           chatID,
		"message_id":        messageID,
		"callback_query_id": callbackQueryID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// GetChatMessageByDate Returns the last message sent in a chat no later than the specified date
// @param chatID Chat identifier
// @param date Point in time (Unix timestamp) relative to which to search for messages
func (client *Client) GetChatMessageByDate(chatID int64, date int32) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":   "getChatMessageByDate",
		"chat_id": chatID,
		"date":    date,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var message Message
	err = json.Unmarshal(result.Raw, &message)
	return &message, err

}

// SendMessage Sends a message. Returns the sent message
// @param chatID Target chat
// @param messageThreadID If not 0, a message thread identifier in which the message will be sent
// @param replyToMessageID Identifier of the message to reply to or 0
// @param options Options to be used to send the message
// @param replyMarkup Markup for replying to the message; for bots only
// @param inputMessageContent The content of the message to be sent
func (client *Client) SendMessage(chatID int64, messageThreadID int64, replyToMessageID int64, options *MessageSendOptions, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":                 "sendMessage",
		"chat_id":               chatID,
		"message_thread_id":     messageThreadID,
		"reply_to_message_id":   replyToMessageID,
		"options":               options,
		"reply_markup":          replyMarkup,
		"input_message_content": inputMessageContent,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// SendBotStartMessage Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
// @param botUserID Identifier of the bot
// @param chatID Identifier of the target chat
// @param parameter A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking)
func (client *Client) SendBotStartMessage(botUserID int32, chatID int64, parameter string) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":       "sendBotStartMessage",
		"bot_user_id": botUserID,
		"chat_id":     chatID,
		"parameter":   parameter,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var message Message
	err = json.Unmarshal(result.Raw, &message)
	return &message, err

}

// SendInlineQueryResultMessage Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
// @param chatID Target chat
// @param messageThreadID If not 0, a message thread identifier in which the message will be sent
// @param replyToMessageID Identifier of a message to reply to or 0
// @param options Options to be used to send the message
// @param queryID Identifier of the inline query
// @param resultID Identifier of the inline result
// @param hideViaBot If true, there will be no mention of a bot, via which the message is sent. Can be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username") and GetOption("venue_search_bot_username")
func (client *Client) SendInlineQueryResultMessage(chatID int64, messageThreadID int64, replyToMessageID int64, options *MessageSendOptions, queryID JSONInt64, resultID string, hideViaBot bool) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":               "sendInlineQueryResultMessage",
		"chat_id":             chatID,
		"message_thread_id":   messageThreadID,
		"reply_to_message_id": replyToMessageID,
		"options":             options,
		"query_id":            queryID,
		"result_id":           resultID,
		"hide_via_bot":        hideViaBot,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// SendChatSetTTLMessage Changes the current TTL setting (sets a new self-destruct timer) in a secret chat and sends the corresponding message
// @param chatID Chat identifier
// @param tTL New TTL value, in seconds
func (client *Client) SendChatSetTTLMessage(chatID int64, tTL int32) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":   "sendChatSetTtlMessage",
		"chat_id": chatID,
		"ttl":     tTL,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var message Message
	err = json.Unmarshal(result.Raw, &message)
	return &message, err

}

// AddLocalMessage Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
// @param chatID Target chat
// @param sender The sender sender of the message
// @param replyToMessageID Identifier of the message to reply to or 0
// @param disableNotification Pass true to disable notification for the message
// @param inputMessageContent The content of the message to be added
func (client *Client) AddLocalMessage(chatID int64, sender MessageSender, replyToMessageID int64, disableNotification bool, inputMessageContent InputMessageContent) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":                 "addLocalMessage",
		"chat_id":               chatID,
		"sender":                sender,
		"reply_to_message_id":   replyToMessageID,
		"disable_notification":  disableNotification,
		"input_message_content": inputMessageContent,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// EditMessageText Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
// @param chatID The chat the message belongs to
// @param messageID Identifier of the message
// @param replyMarkup The new message reply markup; for bots only
// @param inputMessageContent New text content of the message. Should be of type InputMessageText
func (client *Client) EditMessageText(chatID int64, messageID int64, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":                 "editMessageText",
		"chat_id":               chatID,
		"message_id":            messageID,
		"reply_markup":          replyMarkup,
		"input_message_content": inputMessageContent,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// EditMessageLiveLocation Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
// @param chatID The chat the message belongs to
// @param messageID Identifier of the message
// @param replyMarkup The new message reply markup; for bots only
// @param location New location content of the message; may be null. Pass null to stop sharing the live location
// @param heading The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
// @param proximityAlertRadius The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
func (client *Client) EditMessageLiveLocation(chatID int64, messageID int64, replyMarkup ReplyMarkup, location *Location, heading int32, proximityAlertRadius int32) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":                  "editMessageLiveLocation",
		"chat_id":                chatID,
		"message_id":             messageID,
		"reply_markup":           replyMarkup,
		"location":               location,
		"heading":                heading,
		"proximity_alert_radius": proximityAlertRadius,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// EditMessageMedia Edits the content of a message with an animation, an audio, a document, a photo or a video. The media in the message can't be replaced if the message was set to self-destruct. Media can't be replaced by self-destructing media. Media in an album can be edited only to contain a photo or a video. Returns the edited message after the edit is completed on the server side
// @param chatID The chat the message belongs to
// @param messageID Identifier of the message
// @param replyMarkup The new message reply markup; for bots only
// @param inputMessageContent New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo
func (client *Client) EditMessageMedia(chatID int64, messageID int64, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":                 "editMessageMedia",
		"chat_id":               chatID,
		"message_id":            messageID,
		"reply_markup":          replyMarkup,
		"input_message_content": inputMessageContent,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// EditMessageCaption Edits the message content caption. Returns the edited message after the edit is completed on the server side
// @param chatID The chat the message belongs to
// @param messageID Identifier of the message
// @param replyMarkup The new message reply markup; for bots only
// @param caption New message content caption; 0-GetOption("message_caption_length_max") characters
func (client *Client) EditMessageCaption(chatID int64, messageID int64, replyMarkup ReplyMarkup, caption *FormattedText) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":        "editMessageCaption",
		"chat_id":      chatID,
		"message_id":   messageID,
		"reply_markup": replyMarkup,
		"caption":      caption,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// EditMessageReplyMarkup Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
// @param chatID The chat the message belongs to
// @param messageID Identifier of the message
// @param replyMarkup The new message reply markup
func (client *Client) EditMessageReplyMarkup(chatID int64, messageID int64, replyMarkup ReplyMarkup) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":        "editMessageReplyMarkup",
		"chat_id":      chatID,
		"message_id":   messageID,
		"reply_markup": replyMarkup,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}

// SetGameScore Updates the game score of the specified user in the game; for bots only
// @param chatID The chat to which the message with the game belongs
// @param messageID Identifier of the message
// @param editMessage True, if the message should be edited
// @param userID User identifier
// @param score The new score
// @param force Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
func (client *Client) SetGameScore(chatID int64, messageID int64, editMessage bool, userID int32, score int32, force bool) (*Message, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":        "setGameScore",
		"chat_id":      chatID,
		"message_id":   messageID,
		"edit_message": editMessage,
		"user_id":      userID,
		"score":        score,
		"force":        force,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var messageDummy Message
	err = json.Unmarshal(result.Raw, &messageDummy)
	return &messageDummy, err

}
