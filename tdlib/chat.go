// AUTOGENERATED - DO NOT EDIT

package tdlib

import (
	"encoding/json"
	"fmt"
)

// Chat A chat. (Can be a private chat, basic group, supergroup, or secret chat)
type Chat struct {
	tdCommon
	ID                         int64                     `json:"id"`                           // Chat unique identifier
	Type                       ChatType                  `json:"type"`                         // Type of the chat
	Title                      string                    `json:"title"`                        // Chat title
	Photo                      *ChatPhotoInfo            `json:"photo"`                        // Chat photo; may be null
	Permissions                *ChatPermissions          `json:"permissions"`                  // Actions that non-administrator chat members are allowed to take in the chat
	LastMessage                *Message                  `json:"last_message"`                 // Last message in the chat; may be null
	Positions                  []ChatPosition            `json:"positions"`                    // Positions of the chat in chat lists
	IsMarkedAsUnread           bool                      `json:"is_marked_as_unread"`          // True, if the chat is marked as unread
	IsBlocked                  bool                      `json:"is_blocked"`                   // True, if the chat is blocked by the current user and private messages from the chat can't be received
	HasScheduledMessages       bool                      `json:"has_scheduled_messages"`       // True, if the chat has scheduled messages
	CanBeDeletedOnlyForSelf    bool                      `json:"can_be_deleted_only_for_self"` // True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
	CanBeDeletedForAllUsers    bool                      `json:"can_be_deleted_for_all_users"` // True, if the chat messages can be deleted for all users
	CanBeReported              bool                      `json:"can_be_reported"`              // True, if the chat can be reported to Telegram moderators through reportChat
	DefaultDisableNotification bool                      `json:"default_disable_notification"` // Default value of the disable_notification parameter, used when a message is sent to the chat
	UnreadCount                int32                     `json:"unread_count"`                 // Number of unread messages in the chat
	LastReadInboxMessageID     int64                     `json:"last_read_inbox_message_id"`   // Identifier of the last read incoming message
	LastReadOutboxMessageID    int64                     `json:"last_read_outbox_message_id"`  // Identifier of the last read outgoing message
	UnreadMentionCount         int32                     `json:"unread_mention_count"`         // Number of unread messages with a mention/reply in the chat
	NotificationSettings       *ChatNotificationSettings `json:"notification_settings"`        // Notification settings for this chat
	ActionBar                  ChatActionBar             `json:"action_bar"`                   // Describes actions which should be possible to do through a chat action bar; may be null
	ReplyMarkupMessageID       int64                     `json:"reply_markup_message_id"`      // Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	DraftMessage               *DraftMessage             `json:"draft_message"`                // A draft of a message in the chat; may be null
	ClientData                 string                    `json:"client_data"`                  // Contains application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
}

// MessageType return the string telegram-type of Chat
func (chat *Chat) MessageType() string {
	return "chat"
}

// NewChat creates a new Chat
//
// @param iD Chat unique identifier
// @param typeParam Type of the chat
// @param title Chat title
// @param photo Chat photo; may be null
// @param permissions Actions that non-administrator chat members are allowed to take in the chat
// @param lastMessage Last message in the chat; may be null
// @param positions Positions of the chat in chat lists
// @param isMarkedAsUnread True, if the chat is marked as unread
// @param isBlocked True, if the chat is blocked by the current user and private messages from the chat can't be received
// @param hasScheduledMessages True, if the chat has scheduled messages
// @param canBeDeletedOnlyForSelf True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
// @param canBeDeletedForAllUsers True, if the chat messages can be deleted for all users
// @param canBeReported True, if the chat can be reported to Telegram moderators through reportChat
// @param defaultDisableNotification Default value of the disable_notification parameter, used when a message is sent to the chat
// @param unreadCount Number of unread messages in the chat
// @param lastReadInboxMessageID Identifier of the last read incoming message
// @param lastReadOutboxMessageID Identifier of the last read outgoing message
// @param unreadMentionCount Number of unread messages with a mention/reply in the chat
// @param notificationSettings Notification settings for this chat
// @param actionBar Describes actions which should be possible to do through a chat action bar; may be null
// @param replyMarkupMessageID Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
// @param draftMessage A draft of a message in the chat; may be null
// @param clientData Contains application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
func NewChat(iD int64, typeParam ChatType, title string, photo *ChatPhotoInfo, permissions *ChatPermissions, lastMessage *Message, positions []ChatPosition, isMarkedAsUnread bool, isBlocked bool, hasScheduledMessages bool, canBeDeletedOnlyForSelf bool, canBeDeletedForAllUsers bool, canBeReported bool, defaultDisableNotification bool, unreadCount int32, lastReadInboxMessageID int64, lastReadOutboxMessageID int64, unreadMentionCount int32, notificationSettings *ChatNotificationSettings, actionBar ChatActionBar, replyMarkupMessageID int64, draftMessage *DraftMessage, clientData string) *Chat {
	chatTemp := Chat{
		tdCommon:                   tdCommon{Type: "chat"},
		ID:                         iD,
		Type:                       typeParam,
		Title:                      title,
		Photo:                      photo,
		Permissions:                permissions,
		LastMessage:                lastMessage,
		Positions:                  positions,
		IsMarkedAsUnread:           isMarkedAsUnread,
		IsBlocked:                  isBlocked,
		HasScheduledMessages:       hasScheduledMessages,
		CanBeDeletedOnlyForSelf:    canBeDeletedOnlyForSelf,
		CanBeDeletedForAllUsers:    canBeDeletedForAllUsers,
		CanBeReported:              canBeReported,
		DefaultDisableNotification: defaultDisableNotification,
		UnreadCount:                unreadCount,
		LastReadInboxMessageID:     lastReadInboxMessageID,
		LastReadOutboxMessageID:    lastReadOutboxMessageID,
		UnreadMentionCount:         unreadMentionCount,
		NotificationSettings:       notificationSettings,
		ActionBar:                  actionBar,
		ReplyMarkupMessageID:       replyMarkupMessageID,
		DraftMessage:               draftMessage,
		ClientData:                 clientData,
	}

	return &chatTemp
}

// UnmarshalJSON unmarshal to json
func (chat *Chat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                         int64                     `json:"id"`                           // Chat unique identifier
		Title                      string                    `json:"title"`                        // Chat title
		Photo                      *ChatPhotoInfo            `json:"photo"`                        // Chat photo; may be null
		Permissions                *ChatPermissions          `json:"permissions"`                  // Actions that non-administrator chat members are allowed to take in the chat
		LastMessage                *Message                  `json:"last_message"`                 // Last message in the chat; may be null
		Positions                  []ChatPosition            `json:"positions"`                    // Positions of the chat in chat lists
		IsMarkedAsUnread           bool                      `json:"is_marked_as_unread"`          // True, if the chat is marked as unread
		IsBlocked                  bool                      `json:"is_blocked"`                   // True, if the chat is blocked by the current user and private messages from the chat can't be received
		HasScheduledMessages       bool                      `json:"has_scheduled_messages"`       // True, if the chat has scheduled messages
		CanBeDeletedOnlyForSelf    bool                      `json:"can_be_deleted_only_for_self"` // True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
		CanBeDeletedForAllUsers    bool                      `json:"can_be_deleted_for_all_users"` // True, if the chat messages can be deleted for all users
		CanBeReported              bool                      `json:"can_be_reported"`              // True, if the chat can be reported to Telegram moderators through reportChat
		DefaultDisableNotification bool                      `json:"default_disable_notification"` // Default value of the disable_notification parameter, used when a message is sent to the chat
		UnreadCount                int32                     `json:"unread_count"`                 // Number of unread messages in the chat
		LastReadInboxMessageID     int64                     `json:"last_read_inbox_message_id"`   // Identifier of the last read incoming message
		LastReadOutboxMessageID    int64                     `json:"last_read_outbox_message_id"`  // Identifier of the last read outgoing message
		UnreadMentionCount         int32                     `json:"unread_mention_count"`         // Number of unread messages with a mention/reply in the chat
		NotificationSettings       *ChatNotificationSettings `json:"notification_settings"`        // Notification settings for this chat
		ReplyMarkupMessageID       int64                     `json:"reply_markup_message_id"`      // Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
		DraftMessage               *DraftMessage             `json:"draft_message"`                // A draft of a message in the chat; may be null
		ClientData                 string                    `json:"client_data"`                  // Contains application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chat.tdCommon = tempObj.tdCommon
	chat.ID = tempObj.ID
	chat.Title = tempObj.Title
	chat.Photo = tempObj.Photo
	chat.Permissions = tempObj.Permissions
	chat.LastMessage = tempObj.LastMessage
	chat.Positions = tempObj.Positions
	chat.IsMarkedAsUnread = tempObj.IsMarkedAsUnread
	chat.IsBlocked = tempObj.IsBlocked
	chat.HasScheduledMessages = tempObj.HasScheduledMessages
	chat.CanBeDeletedOnlyForSelf = tempObj.CanBeDeletedOnlyForSelf
	chat.CanBeDeletedForAllUsers = tempObj.CanBeDeletedForAllUsers
	chat.CanBeReported = tempObj.CanBeReported
	chat.DefaultDisableNotification = tempObj.DefaultDisableNotification
	chat.UnreadCount = tempObj.UnreadCount
	chat.LastReadInboxMessageID = tempObj.LastReadInboxMessageID
	chat.LastReadOutboxMessageID = tempObj.LastReadOutboxMessageID
	chat.UnreadMentionCount = tempObj.UnreadMentionCount
	chat.NotificationSettings = tempObj.NotificationSettings
	chat.ReplyMarkupMessageID = tempObj.ReplyMarkupMessageID
	chat.DraftMessage = tempObj.DraftMessage
	chat.ClientData = tempObj.ClientData

	fieldType, _ := unmarshalChatType(objMap["type"])
	chat.Type = fieldType

	fieldActionBar, _ := unmarshalChatActionBar(objMap["action_bar"])
	chat.ActionBar = fieldActionBar

	return nil
}

// GetChat Returns information about a chat by its identifier, this is an offline request if the current user is not a bot
// @param chatID Chat identifier
func (client *Client) GetChat(chatID int64) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":   "getChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chatDummy Chat
	err = json.Unmarshal(result.Raw, &chatDummy)
	return &chatDummy, err

}

// SearchPublicChat Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned
// @param username Username to be resolved
func (client *Client) SearchPublicChat(username string) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":    "searchPublicChat",
		"username": username,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chat Chat
	err = json.Unmarshal(result.Raw, &chat)
	return &chat, err

}

// CreatePrivateChat Returns an existing chat corresponding to a given user
// @param userID User identifier
// @param force If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
func (client *Client) CreatePrivateChat(userID int32, force bool) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":   "createPrivateChat",
		"user_id": userID,
		"force":   force,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chat Chat
	err = json.Unmarshal(result.Raw, &chat)
	return &chat, err

}

// CreateBasicGroupChat Returns an existing chat corresponding to a known basic group
// @param basicGroupID Basic group identifier
// @param force If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
func (client *Client) CreateBasicGroupChat(basicGroupID int32, force bool) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":          "createBasicGroupChat",
		"basic_group_id": basicGroupID,
		"force":          force,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chat Chat
	err = json.Unmarshal(result.Raw, &chat)
	return &chat, err

}

// CreateSupergroupChat Returns an existing chat corresponding to a known supergroup or channel
// @param supergroupID Supergroup or channel identifier
// @param force If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
func (client *Client) CreateSupergroupChat(supergroupID int32, force bool) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":         "createSupergroupChat",
		"supergroup_id": supergroupID,
		"force":         force,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chat Chat
	err = json.Unmarshal(result.Raw, &chat)
	return &chat, err

}

// CreateSecretChat Returns an existing chat corresponding to a known secret chat
// @param secretChatID Secret chat identifier
func (client *Client) CreateSecretChat(secretChatID int32) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":          "createSecretChat",
		"secret_chat_id": secretChatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chatDummy Chat
	err = json.Unmarshal(result.Raw, &chatDummy)
	return &chatDummy, err

}

// CreateNewBasicGroupChat Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
// @param userIDs Identifiers of users to be added to the basic group
// @param title Title of the new basic group; 1-128 characters
func (client *Client) CreateNewBasicGroupChat(userIDs []int32, title string) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":    "createNewBasicGroupChat",
		"user_ids": userIDs,
		"title":    title,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chat Chat
	err = json.Unmarshal(result.Raw, &chat)
	return &chat, err

}

// CreateNewSupergroupChat Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
// @param title Title of the new chat; 1-128 characters
// @param isChannel True, if a channel chat should be created
// @param description Chat description; 0-255 characters
// @param location Chat location if a location-based supergroup is being created
func (client *Client) CreateNewSupergroupChat(title string, isChannel bool, description string, location *ChatLocation) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":       "createNewSupergroupChat",
		"title":       title,
		"is_channel":  isChannel,
		"description": description,
		"location":    location,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chat Chat
	err = json.Unmarshal(result.Raw, &chat)
	return &chat, err

}

// CreateNewSecretChat Creates a new secret chat. Returns the newly created chat
// @param userID Identifier of the target user
func (client *Client) CreateNewSecretChat(userID int32) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":   "createNewSecretChat",
		"user_id": userID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chat Chat
	err = json.Unmarshal(result.Raw, &chat)
	return &chat, err

}

// UpgradeBasicGroupChatToSupergroupChat Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
// @param chatID Identifier of the chat to upgrade
func (client *Client) UpgradeBasicGroupChatToSupergroupChat(chatID int64) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":   "upgradeBasicGroupChatToSupergroupChat",
		"chat_id": chatID,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chatDummy Chat
	err = json.Unmarshal(result.Raw, &chatDummy)
	return &chatDummy, err

}

// JoinChatByInviteLink Uses an invite link to add the current user to the chat if possible. The new member will not be added until the chat state has been synchronized with the server
// @param inviteLink Invite link to import; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/"
func (client *Client) JoinChatByInviteLink(inviteLink string) (*Chat, error) {
	result, err := client.SendAndCatch(UpdateData{
		"@type":       "joinChatByInviteLink",
		"invite_link": inviteLink,
	})

	if err != nil {
		return nil, err
	}

	if result.Data["@type"].(string) == "error" {
		return nil, fmt.Errorf("error! code: %d msg: %s", result.Data["code"], result.Data["message"])
	}

	var chat Chat
	err = json.Unmarshal(result.Raw, &chat)
	return &chat, err

}
